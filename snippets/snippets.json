{
    "findExcludeEntity": {
        "scope": "source.e2",
        "prefix": "findExcludeEntity",
        "description": "Exclude entity from future finds",
        "body": "findExcludeEntity()"
    },
    "length": {
        "scope": "source.e2",
        "prefix": "length",
        "description": "s:length\nReturns the length of the string",
        "body": "length()"
    },
    "lastSaidTeam()": {
        "scope": "source.e2",
        "prefix": "lastSaidTeam",
        "description": "e:lastSaidTeam\nReturns 1 if the last message was sent in the team chat, 0 otherwise",
        "body": "lastSaidTeam()"
    },
    "bearing": {
        "scope": "source.e2",
        "prefix": "bearing",
        "description": "Gets the bearing from the first position, at the specified angle, to the second position",
        "body": "bearing(${1:vector}, ${2:angle}, ${3:vector})"
    },
    "qk(n)": {
        "scope": "source.e2",
        "prefix": "qk",
        "description": "Returns N*k",
        "body": "qk(${1:number})"
    },
    "jsonError": {
        "scope": "source.e2",
        "prefix": "jsonError",
        "description": "Returns the last json error",
        "body": "jsonError()"
    },
    "matrix4(xm2)": {
        "scope": "source.e2",
        "prefix": "matrix4",
        "description": "Converts a 2x2 matrix into a 4x4 matrix - all (i,3), (i,4), (3,j) and (4,j) are filled with 0's",
        "body": "matrix4(${3:vector2})"
    },
    "coth(c)": {
        "scope": "source.e2",
        "prefix": "coth",
        "description": "Calculates the hyperbolic cotangent of C",
        "body": "coth()"
    },
    "dsSetScope": {
        "scope": "source.e2",
        "prefix": "dsSetScope",
        "description": "Sets the scope of the E2. Setting the scope determines which signals the E2 can receive. Check the wiki for more info about scopes",
        "body": "dsSetScope(${1:number})"
    },
    "i()": {
        "scope": "source.e2",
        "prefix": "i",
        "description": "q:i\nReturns the i component of the quaternion",
        "body": "i()"
    },
    "npcStop": {
        "scope": "source.e2",
        "prefix": "npcStop",
        "description": "e:npcStop\nStops any anything the NPC is doing, including things it decided to do by itself",
        "body": "npcStop()"
    },
    "findDisallowPlayerProps": {
        "scope": "source.e2",
        "prefix": "findDisallowPlayerProps",
        "description": "Remove entities owned by player with specified name from the whitelist",
        "body": "findDisallowPlayerProps(${1:string})"
    },
    "gTable": {
        "scope": "source.e2",
        "prefix": "gTable",
        "description": "Returns the gTable. The string determines group, and the number determines wether or not the table should be shared",
        "body": "gTable(${1:string}, ${2:number})"
    },
    "qi": {
        "scope": "source.e2",
        "prefix": "qi",
        "description": "Returns quaternion i",
        "body": "qi()"
    },
    "frac": {
        "scope": "source.e2",
        "prefix": "frac",
        "description": "Returns the Fractional part of the Argument (same as floor)",
        "body": "frac(${1:number})"
    },
    "minVec(xv4xv4)": {
        "scope": "source.e2",
        "prefix": "minVec",
        "description": "Returns a vector combining the lowest value components of V1 and V2",
        "body": "minVec(${1:vector4}, ${2:vector4})"
    },
    "setAngles": {
        "scope": "source.e2",
        "prefix": "setAngles",
        "description": "xef:setAngles\nSets the angle of the effect",
        "body": "setAngles(${1:angle})"
    },
    "toChar": {
        "scope": "source.e2",
        "prefix": "toChar",
        "description": "Returns a one-character string from it's ASCII code, where 32 = argument 1 = 255. An empty string is returned for numbers outside that range",
        "body": "toChar(${1:number})"
    },
    "egpMaterialFromScreen": {
        "scope": "source.e2",
        "prefix": "egpMaterialFromScreen",
        "description": "xwl:egpMaterialFromScreen\nSets the material of the object to a current snapshot of the target screen. Note that this only works for players which see both the egp as well the target screen at that time",
        "body": "egpMaterialFromScreen(${1:number})"
    },
    "lower": {
        "scope": "source.e2",
        "prefix": "lower",
        "description": "s:lower\nAll characters are made lowercase",
        "body": "lower()"
    },
    "hasConstraints": {
        "scope": "source.e2",
        "prefix": "hasConstraints",
        "description": "e:hasConstraints\nReturns the number of the constraints E has",
        "body": "hasConstraints()"
    },
    "acosr": {
        "scope": "source.e2",
        "prefix": "acosr",
        "description": "Returns the inverse cosine of the argument, in radians",
        "body": "acosr(${1:number})"
    },
    "setName": {
        "scope": "source.e2",
        "prefix": "setName",
        "description": "Set the name of the E2",
        "body": "setName(${1:string})"
    },
    "cscr": {
        "scope": "source.e2",
        "prefix": "cscr",
        "description": "Returns the cosecant of N radians",
        "body": "cscr(${1:number})"
    },
    "egpRadius": {
        "scope": "source.e2",
        "prefix": "egpRadius",
        "description": "xwl:egpRadius\nChanges the corner radius of the rounded box object",
        "body": "egpRadius(${1:number}, ${2:number})"
    },
    "trimLeft": {
        "scope": "source.e2",
        "prefix": "trimLeft",
        "description": "s:trimLeft\nTrims away opening spaces on the string",
        "body": "trimLeft()"
    },
    "runOnChat": {
        "scope": "source.e2",
        "prefix": "runOnChat",
        "description": "If set to 0, the chip will no longer run on chat events, otherwise it makes this chip execute when someone chats. Only needs to be called once, not in every execution",
        "body": "runOnChat(${1:number})"
    },
    "tanhr": {
        "scope": "source.e2",
        "prefix": "tanhr",
        "description": "Returns the hyperbolic tangent of N radians",
        "body": "tanhr(${1:number})"
    },
    "column": {
        "scope": "source.e2",
        "prefix": "column",
        "description": "xm2:column\nReturns the column as a 2D vector",
        "body": "column(${1:number})"
    },
    "toByte": {
        "scope": "source.e2",
        "prefix": "toByte",
        "description": "Returns the ASCII code of the 1st character in the string",
        "body": "toByte(${1:string})"
    },
    "soundVolume(nnn)": {
        "scope": "source.e2",
        "prefix": "soundVolume",
        "description": "soundVolume(integer Index, Volume, FadeTime), where Volume is a number between 0 and 1. Default Volume is 1",
        "body": "soundVolume(${1:number}, ${2:number}, ${3:number})"
    },
    "setAttachment": {
        "scope": "source.e2",
        "prefix": "setAttachment",
        "description": "xef:setAttachment\nCreates new attachment ID for the effect",
        "body": "setAttachment(${1:number})"
    },
    "holoAlpha": {
        "scope": "source.e2",
        "prefix": "holoAlpha",
        "description": "Sets the transparency (0-255) of the hologram",
        "body": "holoAlpha(${1:number}, ${2:number})"
    },
    "findIncludeClass": {
        "scope": "source.e2",
        "prefix": "findIncludeClass",
        "description": "Include entities with this class (or partial class name) in future finds, and remove others not in the whitelist",
        "body": "findIncludeClass(${1:string})"
    },
    "findUpdateRate": {
        "scope": "source.e2",
        "prefix": "findUpdateRate",
        "description": "Returns the minimum delay between entity find events on a chip",
        "body": "findUpdateRate()"
    },
    "findCanQuery": {
        "scope": "source.e2",
        "prefix": "findCanQuery",
        "description": "Returns 1 if find functions can be used, 0 otherwise",
        "body": "findCanQuery()"
    },
    "egp3DTracker": {
        "scope": "source.e2",
        "prefix": "egp3DTracker",
        "description": "xwl:egp3DTracker\nCreates a 3D tracker object at specified world position",
        "body": "egp3DTracker(${1:number}, ${2:vector})"
    },
    "rangerFlags": {
        "scope": "source.e2",
        "prefix": "rangerFlags",
        "description": "Returns the ranger flags as a string",
        "body": "rangerFlags()"
    },
    "findIncludePlayer": {
        "scope": "source.e2",
        "prefix": "findIncludePlayer",
        "description": "Include player with specified name in future finds, and remove other entities not in the entity whitelist",
        "body": "findIncludePlayer(${1:string})"
    },
    "rowMatrix2": {
        "scope": "source.e2",
        "prefix": "rowMatrix2",
        "description": "Creates a 2x2 matrix with 2D vectors by rows",
        "body": "rowMatrix2(${1:vector2}, ${2:vector2})"
    },
    "writeArray": {
        "scope": "source.e2",
        "prefix": "writeArray",
        "description": "xwl:writeArray\nWrites an array's elements into a piece of memory. Strings and sub-tables (angles, vectors, matrices) are written as pointers to the actual data. Strings are written null-terminated",
        "body": "writeArray(${1:number}, ${2:array})"
    },
    "egpPos(nv)": {
        "scope": "source.e2",
        "prefix": "egpPos",
        "description": "xwl:egpPos\nChanges the world position of the 3D tracker object",
        "body": "egpPos(${1:number}, ${2:vector})"
    },
    "findClipFromClass": {
        "scope": "source.e2",
        "prefix": "findClipFromClass",
        "description": "Filters the list of entities by removing all entities that are of this class",
        "body": "findClipFromClass(${1:string})"
    },
    "clamp(aaa)": {
        "scope": "source.e2",
        "prefix": "clamp",
        "description": "Clamps angle 1's PYR between the PYR of angle 2(min) and angle 3(max)",
        "body": "clamp(${1:angle}, ${2:angle}, ${3:angle})"
    },
    "sunDirection": {
        "scope": "source.e2",
        "prefix": "sunDirection",
        "description": "Returns the vector direction that points towards the sun",
        "body": "sunDirection()"
    },
    "clamp(xv2xv2xv2)": {
        "scope": "source.e2",
        "prefix": "clamp",
        "description": "Clamps vector 1's XY between the XY of vector 2(min) and vector 3(max)",
        "body": "clamp(${1:vector2}, ${2:vector2}, ${3:vector2})"
    },
    "glonDecode": {
        "scope": "source.e2",
        "prefix": "glonDecode",
        "description": "Decodes a string into an array using GLON",
        "body": "glonDecode(${1:string})"
    },
    "clamp(ann)": {
        "scope": "source.e2",
        "prefix": "clamp",
        "description": "Clamps angle 1's PYR between argument 2(min) and argument 3(max)",
        "body": "clamp(${1:angle}, ${2:number}, ${3:number})"
    },
    "matchFirst": {
        "scope": "source.e2",
        "prefix": "matchFirst",
        "description": "s:matchFirst\nruns string.match(S, S2) and returns the first match or an empty string if the match failed",
        "body": "matchFirst(${1:string})"
    },
    "element(nn)": {
        "scope": "source.e2",
        "prefix": "element",
        "description": "xm4:element\nReturns the element with indices (i,j)",
        "body": "element(${1:number}, ${2:number})"
    },
    "printColorDriver": {
        "scope": "source.e2",
        "prefix": "printColorDriver",
        "description": "e:printColorDriver\nLike printColor but prints to the driver of a specified vehicle",
        "body": "printColorDriver(${1:....})"
    },
    "assert": {
        "scope": "source.e2",
        "prefix": "assert",
        "description": "If the argument is 0, shut down the E2 with an error message",
        "body": "assert(${1:number})"
    },
    "clipToTypeid": {
        "scope": "source.e2",
        "prefix": "clipToTypeid",
        "description": "t:clipToTypeid\nRemoves all entries not of the specified type",
        "body": "clipToTypeid(${1:string})"
    },
    "writeUnicodeString": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snn), with an extra argument for the text colour",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:vector})"
    },
    "egpAlign(nnn)": {
        "scope": "source.e2",
        "prefix": "egpAlign",
        "description": "xwl:egpAlign\nChanges the horizontal and vertical alignment. Works on: text and text layout. Numbers can be 0, 1 or 2",
        "body": "egpAlign(${1:number}, ${2:number}, ${3:number})"
    },
    "lastSaid": {
        "scope": "source.e2",
        "prefix": "lastSaid",
        "description": "Returns the last message in the chat log",
        "body": "lastSaid()"
    },
    "eyeTrace": {
        "scope": "source.e2",
        "prefix": "eyeTrace",
        "description": "e:eyeTrace\nPerforms a quick trace from the player's eye. Equivalent to rangerOffset(16384, E:shootPos(), E:eye()), but faster. Does not respect filters or ranger flags",
        "body": "eyeTrace()"
    },
    "numPlayers": {
        "scope": "source.e2",
        "prefix": "numPlayers",
        "description": "Returns the number of players currently in the server",
        "body": "numPlayers()"
    },
    "ceil(xv4)": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds XYZW up to the nearest integer",
        "body": "ceil(${1:vector4})"
    },
    "convarnum": {
        "scope": "source.e2",
        "prefix": "convarnum",
        "description": "Give a console command such as \"sbox_godmode\" and it returns the set value",
        "body": "convarnum(${1:string})"
    },
    "owner": {
        "scope": "source.e2",
        "prefix": "owner",
        "description": "Gets the owner of the expression ( same as entity():owner() )",
        "body": "owner()"
    },
    "rangerPersist": {
        "scope": "source.e2",
        "prefix": "rangerPersist",
        "description": "Passing 0 (the default) resets all ranger flags and filters every execution and after calling ranger/rangerOffset. Passing anything else will make the flags and filters persist until they're changed again",
        "body": "rangerPersist(${1:number})"
    },
    "ceil(xv4n)": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds XYZW up to argument 2's decimal precision",
        "body": "ceil(${1:vector4}, ${2:number})"
    },
    "gmatch": {
        "scope": "source.e2",
        "prefix": "gmatch",
        "description": "s:gmatch\nruns string.gmatch(S, S2) and returns the captures in arrays in a table",
        "body": "gmatch(${1:string})"
    },
    "ceil": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds the Argument up to the nearest Integer",
        "body": "ceil(${1:number})"
    },
    "writeString(snnvnn)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snnvn), with an extra argument for flashing text. 0 or 1 is recommended",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:vector}, ${5:number}, ${6:number})"
    },
    "round(xv2)": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds XY to the nearest integer",
        "body": "round(${1:vector2})"
    },
    "findAllowPlayer": {
        "scope": "source.e2",
        "prefix": "findAllowPlayer",
        "description": "Remove player with specified name from the entity blacklist",
        "body": "findAllowPlayer(${1:string})"
    },
    "runOnHTTP": {
        "scope": "source.e2",
        "prefix": "runOnHTTP",
        "description": "Sets whether to run the expression when a request finishes",
        "body": "runOnHTTP(${1:number})"
    },
    "npcGoWalk": {
        "scope": "source.e2",
        "prefix": "npcGoWalk",
        "description": "e:npcGoWalk\nTells the NPC to walk to position V",
        "body": "npcGoWalk(${1:vector})"
    },
    "egpClearQueue": {
        "scope": "source.e2",
        "prefix": "egpClearQueue",
        "description": "Clears your entire queue",
        "body": "egpClearQueue()"
    },
    "index()": {
        "scope": "source.e2",
        "prefix": "index",
        "description": "b:index\nReturns Bs index in the entity it belongs to. Returns -1 if the bone is invalid or an error occured",
        "body": "index()"
    },
    "elevation": {
        "scope": "source.e2",
        "prefix": "elevation",
        "description": "Gets the elevation from the first position, at the specified angle, to the second position",
        "body": "elevation(${1:vector}, ${2:angle}, ${3:vector})"
    },
    "transpose": {
        "scope": "source.e2",
        "prefix": "transpose",
        "description": "Returns the transpose of a matrix",
        "body": "transpose(${3:vector2})"
    },
    "egpColor(nv)": {
        "scope": "source.e2",
        "prefix": "egpColor",
        "description": "xwl:egpColor\nChanges the color of the object",
        "body": "egpColor(${1:number}, ${2:vector})"
    },
    "rangerOffsetHull(nvvvv)": {
        "scope": "source.e2",
        "prefix": "rangerOffsetHull",
        "description": "Inputs: Distance, StartPos, Direction, Hull MinSize, Hull MaxSize",
        "body": "rangerOffsetHull(${1:number}, ${2:vector}, ${3:vector}, ${4:vector}, ${5:vector})"
    },
    "httpUrlDecode": {
        "scope": "source.e2",
        "prefix": "httpUrlDecode",
        "description": "Returns decoded URL data",
        "body": "httpUrlDecode(${1:string})"
    },
    "toWorld": {
        "scope": "source.e2",
        "prefix": "toWorld",
        "description": "e:toWorld\nTransforms from a vector local to E to a world vector",
        "body": "toWorld(${1:vector})"
    },
    "egpTriangle": {
        "scope": "source.e2",
        "prefix": "egpTriangle",
        "description": "xwl:egpTriangle\nCreates a triangle with specified vertices",
        "body": "egpTriangle(${1:number}, ${2:vector2}, ${3:vector2}, ${4:vector2})"
    },
    "setDiagonal": {
        "scope": "source.e2",
        "prefix": "setDiagonal",
        "description": "m:setDiagonal\nSets the elements of the leading diagonal",
        "body": "setDiagonal(${1:number}, ${2:number}, ${3:number})"
    },
    "egpTextLayout": {
        "scope": "source.e2",
        "prefix": "egpTextLayout",
        "description": "xwl:egpTextLayout\nCreates a text layout object",
        "body": "egpTextLayout(${1:number}, ${2:string}, ${3:vector2}, ${4:vector2})"
    },
    "count()": {
        "scope": "source.e2",
        "prefix": "count",
        "description": "r:count\nReturns the number of entries in the array",
        "body": "count()"
    },
    "bones": {
        "scope": "source.e2",
        "prefix": "bones",
        "description": "e:bones\nReturns an array containing all of Es bones. This array's first element has the index 0!",
        "body": "bones()"
    },
    "dsClkName": {
        "scope": "source.e2",
        "prefix": "dsClkName",
        "description": "Returns the name of the signal",
        "body": "dsClkName()"
    },
    "egpQueueClk": {
        "scope": "source.e2",
        "prefix": "egpQueueClk",
        "description": "Returns 1 if the current execution was caused by the EGP queue system of specified screen",
        "body": "egpQueueClk()"
    },
    "isnan": {
        "scope": "source.e2",
        "prefix": "isnan",
        "description": "Returns 1 if given value is not a number (NaN); otherwise 0.",
        "body": "isnan(${1:number})"
    },
    "cross(v)": {
        "scope": "source.e2",
        "prefix": "cross",
        "description": "v:cross\nGets the vector cross product",
        "body": "cross(${1:vector})"
    },
    "first": {
        "scope": "source.e2",
        "prefix": "first",
        "description": "Returns 1 if the expression was spawned or reset",
        "body": "first()"
    },
    "fileClk": {
        "scope": "source.e2",
        "prefix": "fileClk",
        "description": "Returns whether the execution was run because a file finished uploading and was that file of a specific file name",
        "body": "fileClk(${1:string})"
    },
    "height": {
        "scope": "source.e2",
        "prefix": "height",
        "description": "e:height\nGets the height of a player or npc",
        "body": "height()"
    },
    "round(xv4)": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds XYZW to the nearest integer",
        "body": "round(${1:vector4})"
    },
    "rotate(n)": {
        "scope": "source.e2",
        "prefix": "rotate",
        "description": "xv2:rotate\nRotates a vector by the argument (given in degrees)",
        "body": "rotate(${1:number})"
    },
    "holoShadow": {
        "scope": "source.e2",
        "prefix": "holoShadow",
        "description": "Enables the hologram's shadow",
        "body": "holoShadow(${1:number}, ${2:number})"
    },
    "distanceLeftSolid": {
        "scope": "source.e2",
        "prefix": "distanceLeftSolid",
        "description": "xrd:distanceLeftSolid\nReturns the distance between the position at which the trace left the world and the trace's Start Position",
        "body": "distanceLeftSolid()"
    },
    "playerDamage": {
        "scope": "source.e2",
        "prefix": "playerDamage",
        "description": "Returns 1 if player vs player damage is enabled on the server",
        "body": "playerDamage()"
    },
    "distance2(v)": {
        "scope": "source.e2",
        "prefix": "distance2",
        "description": "v:distance2\nGets the squared distance between vectors",
        "body": "distance2(${1:vector})"
    },
    "inf": {
        "scope": "source.e2",
        "prefix": "inf",
        "description": "Returns a huge constant (infinity)",
        "body": "inf()"
    },
    "findExcludePlayerProps": {
        "scope": "source.e2",
        "prefix": "findExcludePlayerProps",
        "description": "Exclude entities owned by player with specified name from future finds",
        "body": "findExcludePlayerProps(${1:string})"
    },
    "keyReload": {
        "scope": "source.e2",
        "prefix": "keyReload",
        "description": "e:keyReload\nIs the player pressing their reload key?",
        "body": "keyReload()"
    },
    "maxOfType": {
        "scope": "source.e2",
        "prefix": "maxOfType",
        "description": "Returns the maximum allowed of a certain type of entity, i.e. maxOfType(\"wire_thrusters\"). Returns 0 if you enter an invalid parameter",
        "body": "maxOfType(${1:string})"
    },
    "setScale": {
        "scope": "source.e2",
        "prefix": "setScale",
        "description": "xef:setScale\nSets the scale of the effect",
        "body": "setScale(${1:number})"
    },
    "vec": {
        "scope": "source.e2",
        "prefix": "vec",
        "description": "Makes a 3D vector",
        "body": "vec(${1:number})"
    },
    "applyAngForce": {
        "scope": "source.e2",
        "prefix": "applyAngForce",
        "description": "Applies torque to the E2 chip according to the given angle",
        "body": "applyAngForce(${1:angle})"
    },
    "swapRows": {
        "scope": "source.e2",
        "prefix": "swapRows",
        "description": "xm2:swapRows\nSwaps rows",
        "body": "swapRows()"
    },
    "signalClk(ss)": {
        "scope": "source.e2",
        "prefix": "signalClk",
        "description": "Returns 1 if the chip was executed because the signal S2 was sent in the group S, regardless of scope. Returns 0 otherwise",
        "body": "signalClk(${1:string}, ${2:string})"
    },
    "quat(n)": {
        "scope": "source.e2",
        "prefix": "quat",
        "description": "Creates a quaternion with real part equal to N",
        "body": "quat(${1:number})"
    },
    "soundStop(s)": {
        "scope": "source.e2",
        "prefix": "soundStop",
        "description": "Stops the sound stored at the string index and removes the entry",
        "body": "soundStop(${1:string})"
    },
    "setDiagonal(xv4)": {
        "scope": "source.e2",
        "prefix": "setDiagonal",
        "description": "xm4:setDiagonal\nSets the elements of the leading diagonal from the components of a vector",
        "body": "setDiagonal(${1:vector4})"
    },
    "i(n)": {
        "scope": "source.e2",
        "prefix": "i",
        "description": "Returns N*i",
        "body": "i(${1:number})"
    },
    "rgb2hsl": {
        "scope": "source.e2",
        "prefix": "rgb2hsl",
        "description": "Converts V from RGB color space to the HSL color space",
        "body": "rgb2hsl(${1:vector})"
    },
    "matrix4(xm2xm2xm2xm2)": {
        "scope": "source.e2",
        "prefix": "matrix4",
        "description": "Constructs a 4x4 matrix from four 2x2 matrices",
        "body": "matrix4(${3:vector2}, ${6:vector2}, ${9:vector2}, ${12:vector2})"
    },
    "nowirelink": {
        "scope": "source.e2",
        "prefix": "nowirelink",
        "description": "Returns an invalid wirelink",
        "body": "nowirelink()"
    },
    "abs": {
        "scope": "source.e2",
        "prefix": "abs",
        "description": "Returns the Magnitude of the Argument",
        "body": "abs(${1:number})"
    },
    "toWorldAng": {
        "scope": "source.e2",
        "prefix": "toWorldAng",
        "description": "Converts a local position/angle to a world position/angle and returns the angle",
        "body": "toWorldAng(${1:vector}, ${2:angle}, ${3:vector}, ${4:angle})"
    },
    "writeCell": {
        "scope": "source.e2",
        "prefix": "writeCell",
        "description": "xwl:writeCell\nWrites value into specified memory cell. Deprecated, use XWL[N] = X instead",
        "body": "writeCell(${1:number}, ${2:number})"
    },
    "teamPlayers": {
        "scope": "source.e2",
        "prefix": "teamPlayers",
        "description": "Returns the number of players of the team associated with the team number",
        "body": "teamPlayers(${1:number})"
    },
    "slerp": {
        "scope": "source.e2",
        "prefix": "slerp",
        "description": "Performs spherical linear interpolation between Q and Q2. Returns Q for N=0, Q2 for N=1",
        "body": "slerp(${3:number})"
    },
    "find": {
        "scope": "source.e2",
        "prefix": "find",
        "description": "s:find\nReturns the 1st occurrence of the string S, returns 0 if not found",
        "body": "find(${1:string})"
    },
    "applyTorque(v)": {
        "scope": "source.e2",
        "prefix": "applyTorque",
        "description": "b:applyTorque\nApplies torque to the bone according to the given vector, representing the torque axis, magnitude and direction",
        "body": "applyTorque(${1:vector})"
    },
    "toRad(xv4)": {
        "scope": "source.e2",
        "prefix": "toRad",
        "description": "Converts the vector's magnitude from radians to radians",
        "body": "toRad(${1:vector4})"
    },
    "gGetGroup": {
        "scope": "source.e2",
        "prefix": "gGetGroup",
        "description": "Gets the E2's current group",
        "body": "gGetGroup()"
    },
    "setNormal": {
        "scope": "source.e2",
        "prefix": "setNormal",
        "description": "xef:setNormal\nSets the normalized direction vector of the effect",
        "body": "setNormal(${1:vector})"
    },
    "merge(r)": {
        "scope": "source.e2",
        "prefix": "merge",
        "description": "r:merge\nMerges R2 with R. Any variables with the same indexes are overwritten by R2's variables",
        "body": "merge(${1:array})"
    },
    "positive": {
        "scope": "source.e2",
        "prefix": "positive",
        "description": "Returns a vector containing the positive value of each vector component, equivalent to abs(N)",
        "body": "positive(${1:vector2})"
    },
    "httpData": {
        "scope": "source.e2",
        "prefix": "httpData",
        "description": "Returns the data received from the last request",
        "body": "httpData()"
    },
    "atan(c)": {
        "scope": "source.e2",
        "prefix": "atan",
        "description": "Calculates the inverse tangent of C",
        "body": "atan()"
    },
    "floor(vn)": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds XYZ down to argument 2's decimal precision",
        "body": "floor(${1:vector}, ${2:number})"
    },
    "dsProbe": {
        "scope": "source.e2",
        "prefix": "dsProbe",
        "description": "Returns an array of E2s the signal would have been sent to if it had been sent with the specified arguments",
        "body": "dsProbe()"
    },
    "egpBoxOutline": {
        "scope": "source.e2",
        "prefix": "egpBoxOutline",
        "description": "xwl:egpBoxOutline\nCreates an outline box. First 2D vector is the position, second is size",
        "body": "egpBoxOutline(${1:number}, ${2:vector2}, ${3:vector2})"
    },
    "remoteSetCode(st)": {
        "scope": "source.e2",
        "prefix": "remoteSetCode",
        "description": "e:remoteSetCode\nSets the E2's code with main file & includes",
        "body": "remoteSetCode(${1:string}, ${2:table})"
    },
    "isFrozen": {
        "scope": "source.e2",
        "prefix": "isFrozen",
        "description": "e:isFrozen\nIs the entity frozen?",
        "body": "isFrozen()"
    },
    "vonDecode": {
        "scope": "source.e2",
        "prefix": "vonDecode",
        "description": "Decodes a string into an array using vON",
        "body": "vonDecode(${1:string})"
    },
    "egpOrder(n)": {
        "scope": "source.e2",
        "prefix": "egpOrder",
        "description": "xwl:egpOrder\nReturns the order at which the object is rendered",
        "body": "egpOrder(${1:number})"
    },
    "findClearWhiteModelList": {
        "scope": "source.e2",
        "prefix": "findClearWhiteModelList",
        "description": "Clear all entries from the model whitelist",
        "body": "findClearWhiteModelList()"
    },
    "teamName": {
        "scope": "source.e2",
        "prefix": "teamName",
        "description": "Returns the name of the team associated with the team number",
        "body": "teamName(${1:number})"
    },
    "jsonDecodeTable": {
        "scope": "source.e2",
        "prefix": "jsonDecodeTable",
        "description": "Decodes a string into a table using json",
        "body": "jsonDecodeTable(${1:string})"
    },
    "replaceRE": {
        "scope": "source.e2",
        "prefix": "replaceRE",
        "description": "s:replaceRE\nFinds and replaces every occurrence of the first argument using REGEX with the second argument",
        "body": "replaceRE(${1:string}, ${2:string})"
    },
    "writeString(snn)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nA helper function for using the Wired Console Screen. The string will be written to the screen in white text on black background. The number arguments specify the starting position - X/Horizontal (0-29 recommended) and Y/vertical (0-17)",
        "body": "writeString(${1:string}, ${2:number}, ${3:number})"
    },
    "aabbSize": {
        "scope": "source.e2",
        "prefix": "aabbSize",
        "description": "e:aabbSize\nReturns the entity's axis-aligned bounding box size",
        "body": "aabbSize()"
    },
    "jsonEncode(rn)": {
        "scope": "source.e2",
        "prefix": "jsonEncode",
        "description": "Encodes an array into a string using json",
        "body": "jsonEncode(${1:array}, ${2:number})"
    },
    "keyDuck": {
        "scope": "source.e2",
        "prefix": "keyDuck",
        "description": "e:keyDuck\nIs the player pressing their crouch key?",
        "body": "keyDuck()"
    },
    "armor": {
        "scope": "source.e2",
        "prefix": "armor",
        "description": "e:armor\nGets the armor of the player",
        "body": "armor()"
    },
    "findClipToModel": {
        "scope": "source.e2",
        "prefix": "findClipToModel",
        "description": "Filters the list of entities by removing all entities that do NOT have this model",
        "body": "findClipToModel(${1:string})"
    },
    "findClipToEntities": {
        "scope": "source.e2",
        "prefix": "findClipToEntities",
        "description": "Filters the list of entities by removing all entities that are NOT in this array",
        "body": "findClipToEntities(${1:array})"
    },
    "fileLoad": {
        "scope": "source.e2",
        "prefix": "fileLoad",
        "description": "Loads specified file to the server",
        "body": "fileLoad(${1:string})"
    },
    "hostip": {
        "scope": "source.e2",
        "prefix": "hostip",
        "description": "Returns the IP of the server",
        "body": "hostip()"
    },
    "concat(n)": {
        "scope": "source.e2",
        "prefix": "concat",
        "description": "r:concat\nConcatenates all values in the array, starting at index N",
        "body": "concat(${1:number})"
    },
    "min()": {
        "scope": "source.e2",
        "prefix": "min",
        "description": "r:min\nReturns the smallest number in array",
        "body": "min()"
    },
    "findByClass": {
        "scope": "source.e2",
        "prefix": "findByClass",
        "description": "Find all entities with the given class",
        "body": "findByClass(${1:string})"
    },
    "findAllowPlayerProps": {
        "scope": "source.e2",
        "prefix": "findAllowPlayerProps",
        "description": "Remove entities owned by player with specified name from the blacklist",
        "body": "findAllowPlayerProps(${1:string})"
    },
    "concat": {
        "scope": "source.e2",
        "prefix": "concat",
        "description": "t:concat\nConcatenates the array-part of the table",
        "body": "concat()"
    },
    "getName": {
        "scope": "source.e2",
        "prefix": "getName",
        "description": "e:getName\nGet the name of another E2, compatible entity or wiremod component name",
        "body": "getName()"
    },
    "ang(v)": {
        "scope": "source.e2",
        "prefix": "ang",
        "description": "Changes a vector variable into an angle variable. XYZ become PYR respectively",
        "body": "ang(${1:vector})"
    },
    "signalName": {
        "scope": "source.e2",
        "prefix": "signalName",
        "description": "Returns the name of the received signal",
        "body": "signalName()"
    },
    "holoCreate(nvva)": {
        "scope": "source.e2",
        "prefix": "holoCreate",
        "description": "Index, Position, Scale, Angle\nCreates a new hologram entity",
        "body": "holoCreate(${1:number}, ${2:vector}, ${3:vector}, ${4:angle})"
    },
    "isConstrainedTo(s)": {
        "scope": "source.e2",
        "prefix": "isConstrainedTo",
        "description": "e:isConstrainedTo\nReturns the first entity E was constrained to with the given constraint type (see the types list below)",
        "body": "isConstrainedTo(${1:string})"
    },
    "findClipFromName": {
        "scope": "source.e2",
        "prefix": "findClipFromName",
        "description": "Filters the list of entities by removing all entities that do have this name",
        "body": "findClipFromName(${1:string})"
    },
    "cpuUsage": {
        "scope": "source.e2",
        "prefix": "cpuUsage",
        "description": "Returns the average time per tick the server spends running this E2, in seconds (multiply it by 1000000 to get the same value as is displayed on the E2 overlay)",
        "body": "cpuUsage()"
    },
    "matrix(a)": {
        "scope": "source.e2",
        "prefix": "matrix",
        "description": "Returns a 3x3 reference frame matrix as described by the angle A. Multiplying by this matrix will be the same as rotating by the given angle",
        "body": "matrix(${1:angle})"
    },
    "y": {
        "scope": "source.e2",
        "prefix": "y",
        "description": "xv2:y\nGets the y component of the vector",
        "body": "y()"
    },
    "runOnTick": {
        "scope": "source.e2",
        "prefix": "runOnTick",
        "description": "If set to 1, the expression will execute once every game tick",
        "body": "runOnTick(${1:number})"
    },
    "inNoclip": {
        "scope": "source.e2",
        "prefix": "inNoclip",
        "description": "e:inNoclip\nIs the player in noclip mode?",
        "body": "inNoclip()"
    },
    "average": {
        "scope": "source.e2",
        "prefix": "average",
        "description": "r:average\nGives the average of all numbers in array",
        "body": "average()"
    },
    "toUnicodeByte(nn)": {
        "scope": "source.e2",
        "prefix": "toUnicodeByte",
        "description": "s:toUnicodeByte\nReturns the Unicode code-points from the given UTF-8 string",
        "body": "toUnicodeByte(${1:number}, ${2:number})"
    },
    "egpSize": {
        "scope": "source.e2",
        "prefix": "egpSize",
        "description": "xwl:egpSize\nReturns the size of the object",
        "body": "egpSize(${1:number})"
    },
    "dsGetGroups": {
        "scope": "source.e2",
        "prefix": "dsGetGroups",
        "description": "Returns an array of the groups the E2 is in",
        "body": "dsGetGroups()"
    },
    "distance2(xv4)": {
        "scope": "source.e2",
        "prefix": "distance2",
        "description": "xv4:distance2\nGets the squared distance between 4D vectors",
        "body": "distance2(${1:vector4})"
    },
    "soundVolume": {
        "scope": "source.e2",
        "prefix": "soundVolume",
        "description": "soundVolume(string Index, Volume, FadeTime), where Volume is a number between 0 and 1. Default Volume is 1",
        "body": "soundVolume(${1:string}, ${2:number}, ${3:number})"
    },
    "nlerp": {
        "scope": "source.e2",
        "prefix": "nlerp",
        "description": "Performs linear interpolation between Q and Q2. Returns normalized Q for N=0, Q2 for N=1.",
        "body": "nlerp(${3:number})"
    },
    "j": {
        "scope": "source.e2",
        "prefix": "j",
        "description": "q:j\nReturns the j component of the quaternion",
        "body": "j()"
    },
    "npcSetTarget": {
        "scope": "source.e2",
        "prefix": "npcSetTarget",
        "description": "e:npcSetTarget\nSets the npcs current target",
        "body": "npcSetTarget()"
    },
    "sinh(c)": {
        "scope": "source.e2",
        "prefix": "sinh",
        "description": "Calculates the hyperbolic sine of C",
        "body": "sinh()"
    },
    "fileLoaded": {
        "scope": "source.e2",
        "prefix": "fileLoaded",
        "description": "Returns whether or not the file has been loaded onto the server",
        "body": "fileLoaded()"
    },
    "sign": {
        "scope": "source.e2",
        "prefix": "sign",
        "description": "Returns the sign of argument (-1,0,1) [sign(N) = N / abs(N) ]",
        "body": "sign(${1:number})"
    },
    "egpFont": {
        "scope": "source.e2",
        "prefix": "egpFont",
        "description": "xwl:egpFont\nChanges the font and size of the text object",
        "body": "egpFont(${1:number}, ${2:string}, ${3:number})"
    },
    "egpFidelity": {
        "scope": "source.e2",
        "prefix": "egpFidelity",
        "description": "xwl:egpFidelity\nReturns the fidelity of the object",
        "body": "egpFidelity(${1:number})"
    },
    "dateUTC": {
        "scope": "source.e2",
        "prefix": "dateUTC",
        "description": "Returns the server's current time and date in UTC",
        "body": "dateUTC()"
    },
    "fileListClk": {
        "scope": "source.e2",
        "prefix": "fileListClk",
        "description": "Returns whether the execution was run because a list with specified name was uploaded to the server",
        "body": "fileListClk(${1:string})"
    },
    "setElement": {
        "scope": "source.e2",
        "prefix": "setElement",
        "description": "xm2:setElement\nSets an element's value. The first two arguments specify the indices (i,j), the third argument is the value to set it to",
        "body": "setElement(${1:number}, ${2:number}, ${3:number})"
    },
    "velL()": {
        "scope": "source.e2",
        "prefix": "velL",
        "description": "b:velL\nReturns Bs velocity in local coordinates",
        "body": "velL()"
    },
    "vec()": {
        "scope": "source.e2",
        "prefix": "vec",
        "description": "Same as vec(0,0,0)",
        "body": "vec()"
    },
    "round": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds the Argument to the nearest Integer",
        "body": "round(${1:number})"
    },
    "setDiagonal(v)": {
        "scope": "source.e2",
        "prefix": "setDiagonal",
        "description": "m:setDiagonal\nSets the elements of the leading diagonal from the components of a vector",
        "body": "setDiagonal(${1:vector})"
    },
    "shift()": {
        "scope": "source.e2",
        "prefix": "shift",
        "description": "r:shift\nRemoves the first element of the array; all other entries will move down one address and returns 1 if removed",
        "body": "shift()"
    },
    "soundPitch": {
        "scope": "source.e2",
        "prefix": "soundPitch",
        "description": "soundPitch(string Index, integer Pitch) Default Pitch is 100, max is 255. Pitch is scaled linearly (like frequency), rather than by octave",
        "body": "soundPitch(${1:string}, ${2:number})"
    },
    "matrix4(nnnnnnnnnnnnnnnn)": {
        "scope": "source.e2",
        "prefix": "matrix4",
        "description": "Creates a matrix with 16 values in the following order (i.j): (1,1), (1,2), (1,3), (1,4), (2,1) etc",
        "body": "matrix4(${1:number}, ${2:number}, ${3:number}, ${4:number}, ${5:number}, ${6:number}, ${7:number}, ${8:number}, ${9:number}, ${10:number}, ${11:number}, ${12:number}, ${13:number}, ${14:number}, ${15:number}, ${16:number})"
    },
    "toUnicodeChar": {
        "scope": "source.e2",
        "prefix": "toUnicodeChar",
        "description": "Returns a one-character string from it's UNICODE code",
        "body": "toUnicodeChar(${1:number})"
    },
    "max()": {
        "scope": "source.e2",
        "prefix": "max",
        "description": "r:max\nReturns the largest number in array",
        "body": "max()"
    },
    "dsGetGroup": {
        "scope": "source.e2",
        "prefix": "dsGetGroup",
        "description": "Get the name of the group the signal was sent to",
        "body": "dsGetGroup()"
    },
    "radius": {
        "scope": "source.e2",
        "prefix": "radius",
        "description": "e:radius\nGets the size of the object (not precisely, but useful)",
        "body": "radius()"
    },
    "findClearWhiteList": {
        "scope": "source.e2",
        "prefix": "findClearWhiteList",
        "description": "Clear all entries from the entire whitelist",
        "body": "findClearWhiteList()"
    },
    "bearing(v)": {
        "scope": "source.e2",
        "prefix": "bearing",
        "description": "b:bearing\nGets the bearing from the bone to the vector",
        "body": "bearing(${1:vector})"
    },
    "csch": {
        "scope": "source.e2",
        "prefix": "csch",
        "description": "Returns the hyperbolic cosecant of N degrees",
        "body": "csch(${1:number})"
    },
    "round(an)": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds PYR to argument 2's decimal precision",
        "body": "round(${1:angle}, ${2:number})"
    },
    "min(nnnn)": {
        "scope": "source.e2",
        "prefix": "min",
        "description": "Returns the lowest value Argument",
        "body": "min(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "fractionLeftSolid": {
        "scope": "source.e2",
        "prefix": "fractionLeftSolid",
        "description": "xrd:fractionLeftSolid\nSame as RD:fraction() except it represents the distance between the start position and the LeftSolid position",
        "body": "fractionLeftSolid()"
    },
    "npcGetTarget()": {
        "scope": "source.e2",
        "prefix": "npcGetTarget",
        "description": "e:npcGetTarget\nReturns what the npc is currently targeting",
        "body": "npcGetTarget()"
    },
    "vec2": {
        "scope": "source.e2",
        "prefix": "vec2",
        "description": "Makes a 2D vector",
        "body": "vec2(${1:number})"
    },
    "inputType": {
        "scope": "source.e2",
        "prefix": "inputType",
        "description": "xwl:inputType\nReturns the type of input that S is in lowercase. ( \"NORMAL\" is changed to \"number\" )",
        "body": "inputType(${1:string})"
    },
    "minVec": {
        "scope": "source.e2",
        "prefix": "minVec",
        "description": "Returns a vector combining the lowest value components of V1 and V2",
        "body": "minVec(${1:vector2}, ${2:vector2})"
    },
    "holoModelList": {
        "scope": "source.e2",
        "prefix": "holoModelList",
        "description": "Returns the list of valid models\nSee holoModelAny()",
        "body": "holoModelList()"
    },
    "identity2()": {
        "scope": "source.e2",
        "prefix": "identity2",
        "description": "Creates a 2x2 identity matrix",
        "body": "identity2()"
    },
    "vel": {
        "scope": "source.e2",
        "prefix": "vel",
        "description": "e:vel\nGets the velocity of the entity",
        "body": "vel()"
    },
    "exists(n)": {
        "scope": "source.e2",
        "prefix": "exists",
        "description": "r:exists\nReturns 1 if the array contains any value at specified index",
        "body": "exists(${1:number})"
    },
    "inv": {
        "scope": "source.e2",
        "prefix": "inv",
        "description": "Returns the inverse of Q",
        "body": "inv()"
    },
    "setColumn(nv)": {
        "scope": "source.e2",
        "prefix": "setColumn",
        "description": "m:setColumn\nSets the values of a column. The first argument given specifies the column, the vector contains the values to set",
        "body": "setColumn(${1:number}, ${2:vector})"
    },
    "soundPitch(nnn)": {
        "scope": "source.e2",
        "prefix": "soundPitch",
        "description": "soundPitch(integer Index, integer Pitch, integer Fadetime) Default Pitch is 100, max is 255. Pitch is scaled linearly (like frequency), rather than by octave",
        "body": "soundPitch(${1:number}, ${2:number}, ${3:number})"
    },
    "teamColor": {
        "scope": "source.e2",
        "prefix": "teamColor",
        "description": "Returns the color of the team associated with the team number",
        "body": "teamColor(${1:number})"
    },
    "unicodeLength": {
        "scope": "source.e2",
        "prefix": "unicodeLength",
        "description": "s:unicodeLength\nReturns the unicode length of the string",
        "body": "unicodeLength()"
    },
    "rgb2digi(nnnn)": {
        "scope": "source.e2",
        "prefix": "rgb2digi",
        "description": "Converts the RGB color (N,N2,N3) to a number in digital screen format. N4 Specifies a mode, either 0, 2 or 3, corresponding to Digital Screen color modes",
        "body": "rgb2digi(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "vel()": {
        "scope": "source.e2",
        "prefix": "vel",
        "description": "b:vel\nReturns Bs velocity",
        "body": "vel()"
    },
    "toString(xv4)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Gets the vector nicely formatted as a string \"[X,Y,Z,W]",
        "body": "toString(${1:vector4})"
    },
    "arg": {
        "scope": "source.e2",
        "prefix": "arg",
        "description": "Returns the argument of C",
        "body": "arg()"
    },
    "matrix(q)": {
        "scope": "source.e2",
        "prefix": "matrix",
        "description": "Converts Q to a transformation matrix",
        "body": "matrix()"
    },
    "effect": {
        "scope": "source.e2",
        "prefix": "effect",
        "description": "Creates and returns new effect",
        "body": "effect()"
    },
    "mix(vvn)": {
        "scope": "source.e2",
        "prefix": "mix",
        "description": "Combines vector 1's XYZ with vector 2's XYZ by a proportion given by argument 3 (between 0 and 1)",
        "body": "mix(${1:vector}, ${2:vector}, ${3:number})"
    },
    "writeString": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nWrites a null-terminated string to the given address. Returns the next free address or 0 on failure",
        "body": "writeString(${1:number}, ${2:string})"
    },
    "maxquota": {
        "scope": "source.e2",
        "prefix": "maxquota",
        "description": "The ops left before hard quota is exceeded and the expression shuts down",
        "body": "maxquota()"
    },
    "egpLoadFrame": {
        "scope": "source.e2",
        "prefix": "egpLoadFrame",
        "description": "xwl:egpLoadFrame\nLoads the frame with specified index",
        "body": "egpLoadFrame(${1:number})"
    },
    "steamFriends": {
        "scope": "source.e2",
        "prefix": "steamFriends",
        "description": "e:steamFriends\nReturns a Array with E's steam friends on the server E is playing on",
        "body": "steamFriends()"
    },
    "perf(n)": {
        "scope": "source.e2",
        "prefix": "perf",
        "description": "If used as a while loop condition, stabilizes the expression around specified number (in %)",
        "body": "perf(${1:number})"
    },
    "dsClk(s)": {
        "scope": "source.e2",
        "prefix": "dsClk",
        "description": "Returns 1 if the current execution was caused by a datasignal with the specified signal name",
        "body": "dsClk(${1:string})"
    },
    "mod(an)": {
        "scope": "source.e2",
        "prefix": "mod",
        "description": "Returns the remainder after PYR have been divided by argument 2",
        "body": "mod(${1:angle}, ${2:number})"
    },
    "egpSaveFrame": {
        "scope": "source.e2",
        "prefix": "egpSaveFrame",
        "description": "xwl:egpSaveFrame\nSaves the frame under specified index",
        "body": "egpSaveFrame(${1:number})"
    },
    "vec2(xv4)": {
        "scope": "source.e2",
        "prefix": "vec2",
        "description": "Converts a 4D vector into a 2D vector (the z and w components are dropped)",
        "body": "vec2(${1:vector4})"
    },
    "hsv2rgb(nnn)": {
        "scope": "source.e2",
        "prefix": "hsv2rgb",
        "description": "Converts N,N,N from the HSV color space to the RGB color space",
        "body": "hsv2rgb(${1:number}, ${2:number}, ${3:number})"
    },
    "inputs": {
        "scope": "source.e2",
        "prefix": "inputs",
        "description": "xwl:inputs\nReturns an array of all the inputs that XWL has without their types. Returns an empty array if it has none",
        "body": "inputs()"
    },
    "qRotation": {
        "scope": "source.e2",
        "prefix": "qRotation",
        "description": "Returns quaternion for rotation about axis V by angle N",
        "body": "qRotation(${1:vector}, ${2:number})"
    },
    "writeUnicodeString(snnvn)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snnv), with an extra argument for background colour. This is in the form of a 3-digit RGB code. 0 is black, while 999 is white, 900 is pure red and so on",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:vector}, ${5:number})"
    },
    "cosh(c)": {
        "scope": "source.e2",
        "prefix": "cosh",
        "description": "Calculates the hyperbolic cosine of C",
        "body": "cosh()"
    },
    "jsonDecodeTableExternal": {
        "scope": "source.e2",
        "prefix": "jsonDecodeTableExternal",
        "description": "Decodes a string into a table using json",
        "body": "jsonDecodeTableExternal(${1:string})"
    },
    "writeUnicodeString(snnnvn)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snnnv), with an extra argument for flashing text. 0 or 1 is recommended",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:number}, ${5:vector}, ${6:number})"
    },
    "floor(xv4n)": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds XYZW down to argument 2's decimal precision",
        "body": "floor(${1:vector4}, ${2:number})"
    },
    "soundPlay": {
        "scope": "source.e2",
        "prefix": "soundPlay",
        "description": "e:soundPlay\nPlays sound from an entity. soundPlay(string Index, int Duration, string Path to File)",
        "body": "soundPlay(${1:string}, ${2:number}, ${3:string})"
    },
    "rangerHull": {
        "scope": "source.e2",
        "prefix": "rangerHull",
        "description": "Inputs: Distance, Hull BoxSize",
        "body": "rangerHull(${1:number}, ${2:vector})"
    },
    "findToArray": {
        "scope": "source.e2",
        "prefix": "findToArray",
        "description": "Formats the query as an array, R[Index,entity] to get an entity",
        "body": "findToArray()"
    },
    "exp": {
        "scope": "source.e2",
        "prefix": "exp",
        "description": "Returns e to the power of the Argument (same as e()^N but shorter and faster this way)",
        "body": "exp(${1:number})"
    },
    "egpMaterial": {
        "scope": "source.e2",
        "prefix": "egpMaterial",
        "description": "xwl:egpMaterial\nReturns the material of the object",
        "body": "egpMaterial(${1:number})"
    },
    "aabbWorldSize": {
        "scope": "source.e2",
        "prefix": "aabbWorldSize",
        "description": "e:aabbWorldSize\nReturns the rotated entity's world-axis-aligned bounding box size",
        "body": "aabbWorldSize()"
    },
    "isConstrainedTo": {
        "scope": "source.e2",
        "prefix": "isConstrainedTo",
        "description": "e:isConstrainedTo\nReturns the first entity E was constrained to",
        "body": "isConstrainedTo()"
    },
    "signalSender": {
        "scope": "source.e2",
        "prefix": "signalSender",
        "description": "Returns the entity of the chip that sent the signal",
        "body": "signalSender()"
    },
    "qj": {
        "scope": "source.e2",
        "prefix": "qj",
        "description": "Returns j",
        "body": "qj()"
    },
    "matrix4(m)": {
        "scope": "source.e2",
        "prefix": "matrix4",
        "description": "Converts a 3x3 matrix into a 4x4 matrix - all (i,4) and (4,j) are filled with 0's",
        "body": "matrix4()"
    },
    "toAngle": {
        "scope": "source.e2",
        "prefix": "toAngle",
        "description": "xv2:toAngle\nReturns the 2D angle of the vector (given in degrees, -180 to 180)",
        "body": "toAngle()"
    },
    "glonError": {
        "scope": "source.e2",
        "prefix": "glonError",
        "description": "Returns the last glon error",
        "body": "glonError()"
    },
    "egpSizeNum": {
        "scope": "source.e2",
        "prefix": "egpSizeNum",
        "description": "xwl:egpSizeNum\nReturns the size of the text/line/outline object",
        "body": "egpSizeNum(${1:number})"
    },
    "softQuota": {
        "scope": "source.e2",
        "prefix": "softQuota",
        "description": "Returns the size of the soft quota",
        "body": "softQuota()"
    },
    "runOnLast": {
        "scope": "source.e2",
        "prefix": "runOnLast",
        "description": "If set to 1, the chip will run once when it is removed, setting the last() flag when it does",
        "body": "runOnLast(${1:number})"
    },
    "holoVisible": {
        "scope": "source.e2",
        "prefix": "holoVisible",
        "description": "If 0, prevents a specific player from seeing the hologram",
        "body": "holoVisible(${1:number}, ${3:number})"
    },
    "coth": {
        "scope": "source.e2",
        "prefix": "coth",
        "description": "Returns the hyperbolic cotangent of N degrees",
        "body": "coth(${1:number})"
    },
    "setHitBox": {
        "scope": "source.e2",
        "prefix": "setHitBox",
        "description": "xef:setHitBox\nSets the hit box index of the effect",
        "body": "setHitBox(${1:number})"
    },
    "explode": {
        "scope": "source.e2",
        "prefix": "explode",
        "description": "s:explode\nSplits the string into an array, along the boundaries formed by the string S. See also String.Explode",
        "body": "explode(${1:string})"
    },
    "egpText": {
        "scope": "source.e2",
        "prefix": "egpText",
        "description": "xwl:egpText\nCreates a text object",
        "body": "egpText(${1:number}, ${2:string}, ${3:vector2})"
    },
    "setSkin": {
        "scope": "source.e2",
        "prefix": "setSkin",
        "description": "e:setSkin\nSets the skin of an entity",
        "body": "setSkin(${1:number})"
    },
    "trim": {
        "scope": "source.e2",
        "prefix": "trim",
        "description": "s:trim\nTrims away spaces at the beginning and end of a string",
        "body": "trim()"
    },
    "findDisallowEntity": {
        "scope": "source.e2",
        "prefix": "findDisallowEntity",
        "description": "Remove entity from the whitelist",
        "body": "findDisallowEntity()"
    },
    "sinhr": {
        "scope": "source.e2",
        "prefix": "sinhr",
        "description": "Returns the hyperbolic sine of N radians",
        "body": "sinhr(${1:number})"
    },
    "toTable": {
        "scope": "source.e2",
        "prefix": "toTable",
        "description": "xrd:toTable\nConverts the trace data into an E2-style table and returns it. Remember that this returns the raw data, so for matType and hitGroup, it is recommend that you use the functions instead of this table",
        "body": "toTable()"
    },
    "exists": {
        "scope": "source.e2",
        "prefix": "exists",
        "description": "t:exists\nReturns 1 if the table contains any value at specified index",
        "body": "exists(${1:string})"
    },
    "clk": {
        "scope": "source.e2",
        "prefix": "clk",
        "description": "Returns 1 if the current execution was caused by the inserted name",
        "body": "clk(${1:string})"
    },
    "toArray": {
        "scope": "source.e2",
        "prefix": "toArray",
        "description": "t:toArray\nConverts the table into an array. (Note that there is no R:totable() function because E2 arrays do not save typeids)",
        "body": "toArray()"
    },
    "egpGlobalFiltering": {
        "scope": "source.e2",
        "prefix": "egpGlobalFiltering",
        "description": "xwl:egpGlobalFiltering\nChanges the texture filter used to draw all EGP Objects. Works only on EGP Screens. See _TEXFILTER constants (POINT=sharp, ANISOTROPIC=blurry/default)",
        "body": "egpGlobalFiltering(${1:number})"
    },
    "vec2(v)": {
        "scope": "source.e2",
        "prefix": "vec2",
        "description": "Converts a 3D vector into a 2D vector (the z component is dropped)",
        "body": "vec2(${1:vector})"
    },
    "holoRenderFX": {
        "scope": "source.e2",
        "prefix": "holoRenderFX",
        "description": "Changes the RenderFX for a hologram",
        "body": "holoRenderFX(${1:number}, ${2:number})"
    },
    "wrap": {
        "scope": "source.e2",
        "prefix": "wrap",
        "description": "Performs (n1 + n2) % (n2 * 2) - n2",
        "body": "wrap(${1:number}, ${2:number})"
    },
    "trusts": {
        "scope": "source.e2",
        "prefix": "trusts",
        "description": "e:trusts\nIs E2 on the prop protection friends list of E?",
        "body": "trusts()"
    },
    "ioOutputEntities": {
        "scope": "source.e2",
        "prefix": "ioOutputEntities",
        "description": "Returns an array of all entities wired to the output S",
        "body": "ioOutputEntities(${1:string})"
    },
    "findClipToSphere": {
        "scope": "source.e2",
        "prefix": "findClipToSphere",
        "description": "Filters the list of entities by removing all entities NOT within the specified sphere (center, radius)",
        "body": "findClipToSphere(${1:vector}, ${2:number})"
    },
    "isWeapon": {
        "scope": "source.e2",
        "prefix": "isWeapon",
        "description": "e:isWeapon\nIs the entity a weapon?",
        "body": "isWeapon()"
    },
    "findAllowPlayerProps(e)": {
        "scope": "source.e2",
        "prefix": "findAllowPlayerProps",
        "description": "Remove entities owned by specified player from the blacklist",
        "body": "findAllowPlayerProps()"
    },
    "egpVertices": {
        "scope": "source.e2",
        "prefix": "egpVertices",
        "description": "xwl:egpVertices\nReturns an array of the vertices of the object",
        "body": "egpVertices(${1:number})"
    },
    "floor(xv2n)": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds XY down to argument 2's decimal precision",
        "body": "floor(${1:vector2}, ${2:number})"
    },
    "findClipToClass": {
        "scope": "source.e2",
        "prefix": "findClipToClass",
        "description": "Filters the list of entities by removing all entities that are NOT of this class",
        "body": "findClipToClass(${1:string})"
    },
    "setEntIndex": {
        "scope": "source.e2",
        "prefix": "setEntIndex",
        "description": "xef:setEntIndex\nSets the entity of the effect via its index",
        "body": "setEntIndex(${1:number})"
    },
    "holoCreate(nvvaxv4s)": {
        "scope": "source.e2",
        "prefix": "holoCreate",
        "description": "Index, Position, Scale, Angle, Color (RGBA), Model\nCreates a new hologram entity",
        "body": "holoCreate(${1:number}, ${2:vector}, ${3:vector}, ${4:angle}, ${5:vector4}, ${6:string})"
    },
    "toByte(sn)": {
        "scope": "source.e2",
        "prefix": "toByte",
        "description": "Returns the ASCII code of the Nth character in the string",
        "body": "toByte(${1:string}, ${2:number})"
    },
    "tanh": {
        "scope": "source.e2",
        "prefix": "tanh",
        "description": "Returns the hyperbolic tangent of N degrees",
        "body": "tanh(${1:number})"
    },
    "egpPoly": {
        "scope": "source.e2",
        "prefix": "egpPoly",
        "description": "xwl:egpPoly\nCreates a polygon with specified points as array of 2D/4D vectors (x,y)/(x,y,u,v)",
        "body": "egpPoly(${1:number}, ${2:array})"
    },
    "rotate": {
        "scope": "source.e2",
        "prefix": "rotate",
        "description": "v:rotate\nGets the rotated vector",
        "body": "rotate(${1:angle})"
    },
    "egpObjectType": {
        "scope": "source.e2",
        "prefix": "egpObjectType",
        "description": "xwl:egpObjectType\nReturns the type of the object with specified index",
        "body": "egpObjectType(${1:number})"
    },
    "setXyz": {
        "scope": "source.e2",
        "prefix": "setXyz",
        "description": "xwl:setXyz\nSets the X/Y/Z to the corresponding values in the vector",
        "body": "setXyz(${1:vector})"
    },
    "fileCanLoad": {
        "scope": "source.e2",
        "prefix": "fileCanLoad",
        "description": "Returns 1 if the file can be loaded",
        "body": "fileCanLoad()"
    },
    "findDisallowPlayer": {
        "scope": "source.e2",
        "prefix": "findDisallowPlayer",
        "description": "Remove player with specified name from the entity whitelist",
        "body": "findDisallowPlayer(${1:string})"
    },
    "setRoll": {
        "scope": "source.e2",
        "prefix": "setRoll",
        "description": "a:setRoll\nReturns a copy of the angle with Roll replaced (use as Ang = Ang:setRoll(...))",
        "body": "setRoll(${1:number})"
    },
    "findByName": {
        "scope": "source.e2",
        "prefix": "findByName",
        "description": "Find all entities with the given name",
        "body": "findByName(${1:string})"
    },
    "fileList": {
        "scope": "source.e2",
        "prefix": "fileList",
        "description": "Returns an array of file names that have been loaded",
        "body": "fileList(${1:string})"
    },
    "column(n)": {
        "scope": "source.e2",
        "prefix": "column",
        "description": "xm4:column\nReturns the column as a 4D vector",
        "body": "column(${1:number})"
    },
    "fromUnit": {
        "scope": "source.e2",
        "prefix": "fromUnit",
        "description": "Converts specified units to default garrysmod units",
        "body": "fromUnit(${1:string}, ${2:number})"
    },
    "egpAngle(nxv2xv2n)": {
        "scope": "source.e2",
        "prefix": "egpAngle",
        "description": "xwl:egpAngle\nRotates the object around the first vec2 with the second vec2 as offset at angle N",
        "body": "egpAngle(${1:number}, ${2:vector2}, ${3:vector2}, ${4:number})"
    },
    "clone()": {
        "scope": "source.e2",
        "prefix": "clone",
        "description": "r:clone\nReturns a copy of the array",
        "body": "clone()"
    },
    "world": {
        "scope": "source.e2",
        "prefix": "world",
        "description": "Returns the world entity",
        "body": "world()"
    },
    "toNumber(n)": {
        "scope": "source.e2",
        "prefix": "toNumber",
        "description": "s:toNumber\nParses a number from a string. The argument given is the base. I.e. toNumber(16) will parse hex",
        "body": "toNumber(${1:number})"
    },
    "holoColor(nv)": {
        "scope": "source.e2",
        "prefix": "holoColor",
        "description": "Sets the color of the hologram",
        "body": "holoColor(${1:number}, ${2:vector})"
    },
    "eye": {
        "scope": "source.e2",
        "prefix": "eye",
        "description": "e:eye\nGets a players view direction else entity forward direction",
        "body": "eye()"
    },
    "holoCreate(nvvav)": {
        "scope": "source.e2",
        "prefix": "holoCreate",
        "description": "Index, Position, Scale, Angle, Color (RGB)\nCreates a new hologram entity",
        "body": "holoCreate(${1:number}, ${2:vector}, ${3:vector}, ${4:angle}, ${5:vector})"
    },
    "isValid": {
        "scope": "source.e2",
        "prefix": "isValid",
        "description": "e:isValid\nReturns 1 if the entity is valid, 0 otherwise",
        "body": "isValid()"
    },
    "holoClip(nnvve)": {
        "scope": "source.e2",
        "prefix": "holoClip",
        "description": "Defines a plane used to clip a hologram specified by it's index, position, and direction local to the given entity",
        "body": "holoClip(${1:number}, ${2:number}, ${3:vector}, ${4:vector})"
    },
    "csch(c)": {
        "scope": "source.e2",
        "prefix": "csch",
        "description": "Calculates the hyperbolic cosecant of C",
        "body": "csch()"
    },
    "toAngle()": {
        "scope": "source.e2",
        "prefix": "toAngle",
        "description": "q:toAngle\nReturns angle represented by Q",
        "body": "toAngle()"
    },
    "isHiSpeed": {
        "scope": "source.e2",
        "prefix": "isHiSpeed",
        "description": "xwl:isHiSpeed\nReturns true if the linked component is high-speed capable",
        "body": "isHiSpeed()"
    },
    "holoBodygroup": {
        "scope": "source.e2",
        "prefix": "holoBodygroup",
        "description": "Index, Group ID, Group SubID\nSets the bodygroups of the given hologram",
        "body": "holoBodygroup(${1:number}, ${2:number}, ${3:number})"
    },
    "egpOrder": {
        "scope": "source.e2",
        "prefix": "egpOrder",
        "description": "xwl:egpOrder\nSets the order at which the object will be rendered",
        "body": "egpOrder(${1:number}, ${2:number})"
    },
    "randvec(nn)": {
        "scope": "source.e2",
        "prefix": "randvec",
        "description": "Returns a random vector with its components between N1 and N2",
        "body": "randvec(${1:number}, ${2:number})"
    },
    "cbrt": {
        "scope": "source.e2",
        "prefix": "cbrt",
        "description": "Returns the Cube Root of the Argument",
        "body": "cbrt(${1:number})"
    },
    "vec4": {
        "scope": "source.e2",
        "prefix": "vec4",
        "description": "Makes a 4D vector",
        "body": "vec4(${1:number})"
    },
    "findIncludeEntity": {
        "scope": "source.e2",
        "prefix": "findIncludeEntity",
        "description": "Include entity in future finds, and remove others not in the whitelist",
        "body": "findIncludeEntity()"
    },
    "length2": {
        "scope": "source.e2",
        "prefix": "length2",
        "description": "xv2:length2\nGets the squared length of the vector",
        "body": "length2()"
    },
    "writeString(snnv)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snn), with an extra argument for the text colour",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:vector})"
    },
    "setTrails": {
        "scope": "source.e2",
        "prefix": "setTrails",
        "description": "e:setTrails\nStartSize, EndSize, Length, Material, Color (RGB), Alpha. Adds a trail to E with the specified attributes",
        "body": "setTrails(${1:number}, ${2:number}, ${3:number}, ${4:string}, ${5:vector}, ${6:number})"
    },
    "fileClk()": {
        "scope": "source.e2",
        "prefix": "fileClk",
        "description": "Returns whether the execution was run because a file finished uploading",
        "body": "fileClk()"
    },
    "toRad(xv2)": {
        "scope": "source.e2",
        "prefix": "toRad",
        "description": "Converts the vector's magnitude from radians to radians",
        "body": "toRad(${1:vector2})"
    },
    "findExcludePlayer(e)": {
        "scope": "source.e2",
        "prefix": "findExcludePlayer",
        "description": "Exclude specified player from future finds (put it on the entity blacklist)",
        "body": "findExcludePlayer()"
    },
    "holoBodygroups": {
        "scope": "source.e2",
        "prefix": "holoBodygroups",
        "description": "Index, Group ID\nReturns the number of bodygroups in the Group ID of the given hologram",
        "body": "holoBodygroups(${1:number}, ${2:number})"
    },
    "isConstrained": {
        "scope": "source.e2",
        "prefix": "isConstrained",
        "description": "e:isConstrained\nReturns 1 if E has constraints, 0 if not",
        "body": "isConstrained()"
    },
    "findClipFromEntity": {
        "scope": "source.e2",
        "prefix": "findClipFromEntity",
        "description": "Filters the list of entities by removing this entity",
        "body": "findClipFromEntity()"
    },
    "hsv2rgb": {
        "scope": "source.e2",
        "prefix": "hsv2rgb",
        "description": "Converts V from the HSV color space to the RGB color space",
        "body": "hsv2rgb(${1:vector})"
    },
    "setColor(xv4)": {
        "scope": "source.e2",
        "prefix": "setColor",
        "description": "e:setColor\nSets the color and alpha (as 4D vector) of the entity",
        "body": "setColor(${1:vector4})"
    },
    "toString(c)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Formats C as a string",
        "body": "toString()"
    },
    "soundPitch(nn)": {
        "scope": "source.e2",
        "prefix": "soundPitch",
        "description": "soundPitch(integer Index, integer Pitch) Default Pitch is 100, max is 255. Pitch is scaled linearly (like frequency), rather than by octave",
        "body": "soundPitch(${1:number}, ${2:number})"
    },
    "signalSetOnRemove": {
        "scope": "source.e2",
        "prefix": "signalSetOnRemove",
        "description": "Sets the signal that the chip sends when it is removed from the world",
        "body": "signalSetOnRemove(${1:string}, ${2:number})"
    },
    "ceil(xv2)": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds XY up to the nearest integer",
        "body": "ceil(${1:vector2})"
    },
    "findDisallowModel": {
        "scope": "source.e2",
        "prefix": "findDisallowModel",
        "description": "Remove entities with this model (or partial model name) from the whitelist",
        "body": "findDisallowModel(${1:string})"
    },
    "diagonal(m)": {
        "scope": "source.e2",
        "prefix": "diagonal",
        "description": "Returns a vector comprising the elements along the leading diagonal",
        "body": "diagonal()"
    },
    "map": {
        "scope": "source.e2",
        "prefix": "map",
        "description": "Returns the current map name",
        "body": "map()"
    },
    "inrange(vvv)": {
        "scope": "source.e2",
        "prefix": "inrange",
        "description": "Returns 1 if each component of V is between (or is equal to) the components of Vmin and Vmax",
        "body": "inrange(${1:vector}, ${2:vector}, ${3:vector})"
    },
    "inVehicle": {
        "scope": "source.e2",
        "prefix": "inVehicle",
        "description": "e:inVehicle\nIs the player in a vehicle?",
        "body": "inVehicle()"
    },
    "swapColumns(nn)": {
        "scope": "source.e2",
        "prefix": "swapColumns",
        "description": "xm4:swapColumns\nSwaps the two columns specified",
        "body": "swapColumns(${1:number}, ${2:number})"
    },
    "minVec(vv)": {
        "scope": "source.e2",
        "prefix": "minVec",
        "description": "Returns a vector combining the lowest value components of V1 and V2",
        "body": "minVec(${1:vector}, ${2:vector})"
    },
    "toString(e)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Converts entity to string",
        "body": "toString()"
    },
    "holoBoneScale(ns)": {
        "scope": "source.e2",
        "prefix": "holoBoneScale",
        "description": "Returns the scale of the given hologram named bone",
        "body": "holoBoneScale(${1:number}, ${2:string})"
    },
    "soundDuration": {
        "scope": "source.e2",
        "prefix": "soundDuration",
        "description": "soundDuration(string Path to File) Returns the duration of the sound. Note: If the server hasn't the file it returns 60",
        "body": "soundDuration(${1:string})"
    },
    "writeUnicodeString(snnvv)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snnv), with an extra argument for background colour",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:vector}, ${5:vector})"
    },
    "stopAllTimers": {
        "scope": "source.e2",
        "prefix": "stopAllTimers",
        "description": "Stops all timers",
        "body": "stopAllTimers()"
    },
    "jsonEncodeExternal": {
        "scope": "source.e2",
        "prefix": "jsonEncodeExternal",
        "description": "Encodes a table into a string using json, in a form that is suitable to be exported to external resources. Unfortunately, arrays are ignored because E2 contains many ambiguous types, and arrays don't keep track of those types. You will have to convert your array to a table manually before encoding it.",
        "body": "jsonEncodeExternal(${1:table})"
    },
    "vonDecodeTable": {
        "scope": "source.e2",
        "prefix": "vonDecodeTable",
        "description": "Decodes a string into a table using vON",
        "body": "vonDecodeTable(${1:string})"
    },
    "setRow(nxv4)": {
        "scope": "source.e2",
        "prefix": "setRow",
        "description": "xm4:setRow\nSets the values of a row. The first argument given specifies the row, the vector contains the values to set",
        "body": "setRow(${1:number}, ${2:vector4})"
    },
    "holoModelAny": {
        "scope": "source.e2",
        "prefix": "holoModelAny",
        "description": "Returns 1 if models outside of holoModelList can be used.\nReads convar 'wire_holograms_modelany'",
        "body": "holoModelAny()"
    },
    "fileStatus": {
        "scope": "source.e2",
        "prefix": "fileStatus",
        "description": "Returns the status of the upload in progress. Returns one of _FILE_UNKNOWN, _FILE_OK, _FILE_TIMEOUT, _FILE_404 or _FILE_TRANSFER_ERROR",
        "body": "fileStatus()"
    },
    "ceil(an)": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds PYR up to argument 2's decimal precision",
        "body": "ceil(${1:angle}, ${2:number})"
    },
    "findIncludePlayerProps(e)": {
        "scope": "source.e2",
        "prefix": "findIncludePlayerProps",
        "description": "Include entities owned by specified player in future finds, and remove others not in the whitelist",
        "body": "findIncludePlayerProps()"
    },
    "inrange(xv4xv4xv4)": {
        "scope": "source.e2",
        "prefix": "inrange",
        "description": "Returns 1 if each component of V is between (or is equal to) the components of Vmin and Vmax",
        "body": "inrange(${1:vector4}, ${2:vector4}, ${3:vector4})"
    },
    "bone()": {
        "scope": "source.e2",
        "prefix": "bone",
        "description": "xrd:bone\nReturns the bone of the input ranger data trace IF it hit a bone, else returns nil",
        "body": "bone()"
    },
    "floor(xv2)": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds XY down to the nearest integer",
        "body": "floor(${1:vector2})"
    },
    "soundVolume(sn)": {
        "scope": "source.e2",
        "prefix": "soundVolume",
        "description": "soundVolume(string Index, Volume), where Volume is a number between 0 and 1. Default Volume is 1",
        "body": "soundVolume(${1:string}, ${2:number})"
    },
    "keyClk": {
        "scope": "source.e2",
        "prefix": "keyClk",
        "description": "Returns the player that pressed/released the key if the E2 was triggered by runOnKeys",
        "body": "keyClk()"
    },
    "maxIndex()": {
        "scope": "source.e2",
        "prefix": "maxIndex",
        "description": "r:maxIndex\nReturns the index of the largest number in array",
        "body": "maxIndex()"
    },
    "setColumn(nnnnn)": {
        "scope": "source.e2",
        "prefix": "setColumn",
        "description": "xm4:setColumn\nSets the values of a column. The first argument given specifies the column(i), the following arguments are the values i1, i2, i3, i4",
        "body": "setColumn(${1:number}, ${2:number}, ${3:number}, ${4:number}, ${5:number})"
    },
    "steamIDTo64": {
        "scope": "source.e2",
        "prefix": "steamIDTo64",
        "description": "Converts Steam ID to Steam Community ID",
        "body": "steamIDTo64(${1:string})"
    },
    "transpose(m)": {
        "scope": "source.e2",
        "prefix": "transpose",
        "description": "Returns the transpose of a matrix",
        "body": "transpose()"
    },
    "steamID64": {
        "scope": "source.e2",
        "prefix": "steamID64",
        "description": "e:steamID64\nGets the Steam Community ID (aka Steam64) of the given player",
        "body": "steamID64()"
    },
    "runOnList": {
        "scope": "source.e2",
        "prefix": "runOnList",
        "description": "Specifies whether the E2 will run when a list finishes uploading",
        "body": "runOnList(${1:number})"
    },
    "httpRequest": {
        "scope": "source.e2",
        "prefix": "httpRequest",
        "description": "Starts a new request",
        "body": "httpRequest(${1:string})"
    },
    "npcGiveWeapon": {
        "scope": "source.e2",
        "prefix": "npcGiveWeapon",
        "description": "e:npcGiveWeapon\nGives the NPC an SMG",
        "body": "npcGiveWeapon()"
    },
    "egpScrW": {
        "scope": "source.e2",
        "prefix": "egpScrW",
        "description": "Returns the player's screen resolution width",
        "body": "egpScrW()"
    },
    "egpMaterial(ns)": {
        "scope": "source.e2",
        "prefix": "egpMaterial",
        "description": "xwl:egpMaterial\nChanges the material of the object",
        "body": "egpMaterial(${1:number}, ${2:string})"
    },
    "signalSenderId": {
        "scope": "source.e2",
        "prefix": "signalSenderId",
        "description": "Returns the entity ID of the chip that sent the signal. Useful if the entity doesn't exist anymore",
        "body": "signalSenderId()"
    },
    "eyeTraceCursor": {
        "scope": "source.e2",
        "prefix": "eyeTraceCursor",
        "description": "e:eyeTraceCursor\nSame as eyeTrace, except it also works when the player (for example) is holding down C",
        "body": "eyeTraceCursor()"
    },
    "soundPlay(nns)": {
        "scope": "source.e2",
        "prefix": "soundPlay",
        "description": "e:soundPlay\nPlays sound from an entity. soundPlay(int Index, int Duration, string Path to File)",
        "body": "soundPlay(${1:number}, ${2:number}, ${3:string})"
    },
    "hsl2rgb(nnn)": {
        "scope": "source.e2",
        "prefix": "hsl2rgb",
        "description": "Converts N,N,N from the HSL color space to the RGB color space",
        "body": "hsl2rgb(${1:number}, ${2:number}, ${3:number})"
    },
    "vec4(xv2)": {
        "scope": "source.e2",
        "prefix": "vec4",
        "description": "Converts a 2D vector into a 4D vector (the z and w components are set to 0)",
        "body": "vec4(${1:vector2})"
    },
    "findClipFromEntities": {
        "scope": "source.e2",
        "prefix": "findClipFromEntities",
        "description": "Filters the list of entities by removing all entities that are in this array",
        "body": "findClipFromEntities(${1:array})"
    },
    "setZ": {
        "scope": "source.e2",
        "prefix": "setZ",
        "description": "v:setZ\nReturns a copy of the vector with Z replaced (use as Vec = Vec:setZ(...))",
        "body": "setZ(${1:number})"
    },
    "attachmentAng": {
        "scope": "source.e2",
        "prefix": "attachmentAng",
        "description": "e:attachmentAng\nReturns Es attachment angle associated with attachmentID",
        "body": "attachmentAng(${1:number})"
    },
    "hasInput": {
        "scope": "source.e2",
        "prefix": "hasInput",
        "description": "xwl:hasInput\nReturns true if the linked component has an input of the specified name",
        "body": "hasInput(${1:string})"
    },
    "httpClk": {
        "scope": "source.e2",
        "prefix": "httpClk",
        "description": "Returns whether the execution was run because of a completed request",
        "body": "httpClk()"
    },
    "soundStop(nn)": {
        "scope": "source.e2",
        "prefix": "soundStop",
        "description": "Fades the sound stored at the first input's integer index in the second input's amount of seconds and removes the entry",
        "body": "soundStop(${1:number}, ${2:number})"
    },
    "forward": {
        "scope": "source.e2",
        "prefix": "forward",
        "description": "e:forward\nGets the forward direction of the entity 2)",
        "body": "forward()"
    },
    "egpAlpha(n)": {
        "scope": "source.e2",
        "prefix": "egpAlpha",
        "description": "xwl:egpAlpha\nReturns the alpha of the object",
        "body": "egpAlpha(${1:number})"
    },
    "keyvalues": {
        "scope": "source.e2",
        "prefix": "keyvalues",
        "description": "e:keyvalues\nReturns the keyvalue table of an entity",
        "body": "keyvalues()"
    },
    "podStripWeapons": {
        "scope": "source.e2",
        "prefix": "podStripWeapons",
        "description": "e:podStripWeapons\nStrips player in vehicle",
        "body": "podStripWeapons()"
    },
    "findExcludePlayer": {
        "scope": "source.e2",
        "prefix": "findExcludePlayer",
        "description": "Exclude player with specified name from future finds (put it on the entity blacklist)",
        "body": "findExcludePlayer(${1:string})"
    },
    "isWeldedTo": {
        "scope": "source.e2",
        "prefix": "isWeldedTo",
        "description": "e:isWeldedTo\nReturns the first entity E was welded to",
        "body": "isWeldedTo()"
    },
    "soundStop(sn)": {
        "scope": "source.e2",
        "prefix": "soundStop",
        "description": "Fades the sound stored at the string index in the integer input's amount of seconds and removes the entry",
        "body": "soundStop(${1:string}, ${2:number})"
    },
    "randint(nn)": {
        "scope": "source.e2",
        "prefix": "randint",
        "description": "Returns a random integer in the specified interval [a <= x <= b ]",
        "body": "randint(${1:number}, ${2:number})"
    },
    "conj": {
        "scope": "source.e2",
        "prefix": "conj",
        "description": "Returns the conjugate of C",
        "body": "conj()"
    },
    "det(m)": {
        "scope": "source.e2",
        "prefix": "det",
        "description": "Returns the determinant of a matrix (Does not work for 4x4 matrices)",
        "body": "det()"
    },
    "egpSize(nn)": {
        "scope": "source.e2",
        "prefix": "egpSize",
        "description": "xwl:egpSize\nChanges the size of the text/line/outline object",
        "body": "egpSize(${1:number}, ${2:number})"
    },
    "quat(a)": {
        "scope": "source.e2",
        "prefix": "quat",
        "description": "Converts A to a quaternion",
        "body": "quat(${1:angle})"
    },
    "holoParent(nn)": {
        "scope": "source.e2",
        "prefix": "holoParent",
        "description": "Parents the hologram to another hologram",
        "body": "holoParent(${1:number}, ${2:number})"
    },
    "matchFirst(sn)": {
        "scope": "source.e2",
        "prefix": "matchFirst",
        "description": "s:matchFirst\nruns string.match(S, S2, N) and returns the first match or an empty string if the match failed",
        "body": "matchFirst(${1:string}, ${2:number})"
    },
    "rangerHull(nnnv)": {
        "scope": "source.e2",
        "prefix": "rangerHull",
        "description": "Inputs: Distance, X Skew, Y Skew, Hull BoxSize",
        "body": "rangerHull(${1:number}, ${2:number}, ${3:number}, ${4:vector})"
    },
    "log10": {
        "scope": "source.e2",
        "prefix": "log10",
        "description": "Returns the logarithm to base 10 of the Argument",
        "body": "log10(${1:number})"
    },
    "maxIndex": {
        "scope": "source.e2",
        "prefix": "maxIndex",
        "description": "t:maxIndex\nReturns the index of the largest numerical entry in the array-part",
        "body": "maxIndex()"
    },
    "sechr": {
        "scope": "source.e2",
        "prefix": "sechr",
        "description": "Returns the hyperbolic secant of N radians",
        "body": "sechr(${1:number})"
    },
    "airDensity": {
        "scope": "source.e2",
        "prefix": "airDensity",
        "description": "Returns air density (affects how drag slows down props)",
        "body": "airDensity()"
    },
    "toDeg(xv2)": {
        "scope": "source.e2",
        "prefix": "toDeg",
        "description": "Converts the vector's magnitude from radians to degrees",
        "body": "toDeg(${1:vector2})"
    },
    "entity": {
        "scope": "source.e2",
        "prefix": "entity",
        "description": "Gets the entity associated with the id",
        "body": "entity(${1:number})"
    },
    "selfDestructAll": {
        "scope": "source.e2",
        "prefix": "selfDestructAll",
        "description": "Removes the expression and all constrained props",
        "body": "selfDestructAll()"
    },
    "setY(n)": {
        "scope": "source.e2",
        "prefix": "setY",
        "description": "xv4:setY\nReturns a copy of the 4D vector with Y replaced (use as Vec4 = Vec4:setY(...))",
        "body": "setY(${1:number})"
    },
    "table": {
        "scope": "source.e2",
        "prefix": "table",
        "description": "Returns a table with the values specified in the array-part",
        "body": "table()"
    },
    "clone": {
        "scope": "source.e2",
        "prefix": "clone",
        "description": "t:clone\nReturns a copy of the table",
        "body": "clone()"
    },
    "isPlayerHolding": {
        "scope": "source.e2",
        "prefix": "isPlayerHolding",
        "description": "e:isPlayerHolding\nIs the entity being held by a player?",
        "body": "isPlayerHolding()"
    },
    "aimEntity": {
        "scope": "source.e2",
        "prefix": "aimEntity",
        "description": "e:aimEntity\nReturns the entity that the entity is aiming at",
        "body": "aimEntity()"
    },
    "holoCreate(n)": {
        "scope": "source.e2",
        "prefix": "holoCreate",
        "description": "Index\nCreates a new hologram entity",
        "body": "holoCreate(${1:number})"
    },
    "teamScore": {
        "scope": "source.e2",
        "prefix": "teamScore",
        "description": "Returns the score of the team associated with the team number",
        "body": "teamScore(${1:number})"
    },
    "clip2": {
        "scope": "source.e2",
        "prefix": "clip2",
        "description": "e:clip2\nReturns the amount of ammo in the secondary clip of weapon E, -1 if there is no secondary clip 1)",
        "body": "clip2()"
    },
    "holoClipsAvailable": {
        "scope": "source.e2",
        "prefix": "holoClipsAvailable",
        "description": "Returns the maximum number of clipping planes allowed per hologram",
        "body": "holoClipsAvailable()"
    },
    "writeString(snnnn)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snnn), with an extra argument for background colour. 3-digit RGB again",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:number}, ${5:number})"
    },
    "fileReadList": {
        "scope": "source.e2",
        "prefix": "fileReadList",
        "description": "Returns the contents of the last uploaded list",
        "body": "fileReadList()"
    },
    "concat(snn)": {
        "scope": "source.e2",
        "prefix": "concat",
        "description": "r:concat\nConcatenates all values in the array, starting at index N1 and ending at N2, with string S in between each",
        "body": "concat(${1:string}, ${2:number}, ${3:number})"
    },
    "playersAdmins": {
        "scope": "source.e2",
        "prefix": "playersAdmins",
        "description": "Returns an array containing all admins on the server",
        "body": "playersAdmins()"
    },
    "playersSuperAdmins": {
        "scope": "source.e2",
        "prefix": "playersSuperAdmins",
        "description": "Returns an array containing all super admins on the server",
        "body": "playersSuperAdmins()"
    },
    "floor(a)": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds PYR down to the nearest integer",
        "body": "floor(${1:angle})"
    },
    "aimBone()": {
        "scope": "source.e2",
        "prefix": "aimBone",
        "description": "e:aimBone\nReturns the bone the player is currently aiming at",
        "body": "aimBone()"
    },
    "inrange(aaa)": {
        "scope": "source.e2",
        "prefix": "inrange",
        "description": "Returns 1 if each component of A is between (or is equal to) the components of Amin and Amax",
        "body": "inrange(${1:angle}, ${2:angle}, ${3:angle})"
    },
    "toWorldAxis": {
        "scope": "source.e2",
        "prefix": "toWorldAxis",
        "description": "e:toWorldAxis\nTransforms an axis local to E to a global axis",
        "body": "toWorldAxis(${1:vector})"
    },
    "bShl": {
        "scope": "source.e2",
        "prefix": "bShl",
        "description": "Performs bitwise shift left on the first number by the amount of the second",
        "body": "bShl(${1:number}, ${2:number})"
    },
    "removing": {
        "scope": "source.e2",
        "prefix": "removing",
        "description": "Returns 1 if this is the last() execution and caused by the entity being removed",
        "body": "removing()"
    },
    "signalClk(sn)": {
        "scope": "source.e2",
        "prefix": "signalClk",
        "description": "Returns 1 if the chip was executed because the signal S was sent to the scope N, regardless of group. Returns 0 otherwise",
        "body": "signalClk(${1:string}, ${2:number})"
    },
    "findClearBlackList": {
        "scope": "source.e2",
        "prefix": "findClearBlackList",
        "description": "Clear all entries from the entire blacklist",
        "body": "findClearBlackList()"
    },
    "lastConnectedPlayer": {
        "scope": "source.e2",
        "prefix": "lastConnectedPlayer",
        "description": "Returns the last player to connect.",
        "body": "lastConnectedPlayer()"
    },
    "egpParent": {
        "scope": "source.e2",
        "prefix": "egpParent",
        "description": "xwl:egpParent\nReturns the index of the parent object",
        "body": "egpParent(${1:number})"
    },
    "difference": {
        "scope": "source.e2",
        "prefix": "difference",
        "description": "t:difference\nRemoves all variables with keys that exist in T2",
        "body": "difference(${1:table})"
    },
    "vec(q)": {
        "scope": "source.e2",
        "prefix": "vec",
        "description": "Converts Q to a vector by dropping the real component",
        "body": "vec()"
    },
    "team": {
        "scope": "source.e2",
        "prefix": "team",
        "description": "e:team\nReturns the team number a player is on",
        "body": "team()"
    },
    "printTable(r)": {
        "scope": "source.e2",
        "prefix": "printTable",
        "description": "Prints an array like the lua function PrintTable does, except to the chat area",
        "body": "printTable(${1:array})"
    },
    "vec4(v)": {
        "scope": "source.e2",
        "prefix": "vec4",
        "description": "Converts a 3D vector into a 4D vector (the w component is set to 0)",
        "body": "vec4(${1:vector})"
    },
    "clk()": {
        "scope": "source.e2",
        "prefix": "clk",
        "description": "Returns 1 if the current execution was caused by the interval",
        "body": "clk()"
    },
    "applyAngForce(a)": {
        "scope": "source.e2",
        "prefix": "applyAngForce",
        "description": "b:applyAngForce\nApplies torque to the bone according to the given angle",
        "body": "applyAngForce(${1:angle})"
    },
    "getPlayerColor": {
        "scope": "source.e2",
        "prefix": "getPlayerColor",
        "description": "e:getPlayerColor\nReturns the player's model color as a vector (R,G,B)",
        "body": "getPlayerColor()"
    },
    "printColorC(r)": {
        "scope": "source.e2",
        "prefix": "printColorC",
        "description": "Like printColorC(...), except taking an array containing all the parameters",
        "body": "printColorC(${1:array})"
    },
    "replace": {
        "scope": "source.e2",
        "prefix": "replace",
        "description": "s:replace\nFinds and replaces every occurrence of the first argument with the second argument",
        "body": "replace(${1:string}, ${2:string})"
    },
    "xyz": {
        "scope": "source.e2",
        "prefix": "xyz",
        "description": "xwl:xyz\nRetrieves the X/Y/Z as the corresponding values in the vector",
        "body": "xyz()"
    },
    "findClearWhitePlayerPropList": {
        "scope": "source.e2",
        "prefix": "findClearWhitePlayerPropList",
        "description": "Clear all entries from the prop owner whitelist",
        "body": "findClearWhitePlayerPropList()"
    },
    "changed": {
        "scope": "source.e2",
        "prefix": "changed",
        "description": "Checks if the value or variable was changed. Accepts any type except table and array",
        "body": "changed()"
    },
    "add": {
        "scope": "source.e2",
        "prefix": "add",
        "description": "t:add\nAdds the contents of the second table to the end of the first table. Returns new table",
        "body": "add(${1:table})"
    },
    "setFlags": {
        "scope": "source.e2",
        "prefix": "setFlags",
        "description": "xef:setFlags\nSets the flags of the effect",
        "body": "setFlags(${1:number})"
    },
    "egpLineStrip(nr)": {
        "scope": "source.e2",
        "prefix": "egpLineStrip",
        "description": "xwl:egpLineStrip\nCreates a curve with specified points as array of 2D/4D vectors (x,y)/(x,y,u,v)",
        "body": "egpLineStrip(${1:number}, ${2:array})"
    },
    "egpCursor": {
        "scope": "source.e2",
        "prefix": "egpCursor",
        "description": "xwl:egpCursor\nReturns the specified player's aim position on the screen",
        "body": "egpCursor()"
    },
    "surfaceArea": {
        "scope": "source.e2",
        "prefix": "surfaceArea",
        "description": "e:surfaceArea\nGets the surface area of the entity",
        "body": "surfaceArea()"
    },
    "keyPressed": {
        "scope": "source.e2",
        "prefix": "keyPressed",
        "description": "e:keyPressed\nIs the player pressing the KEY_ enumeration [S]? For example, 'W', 'K', '4', 'COMMA'",
        "body": "keyPressed(${1:string})"
    },
    "aimPos": {
        "scope": "source.e2",
        "prefix": "aimPos",
        "description": "e:aimPos\nReturns the point that the entity is looking at",
        "body": "aimPos()"
    },
    "cothr": {
        "scope": "source.e2",
        "prefix": "cothr",
        "description": "Returns the hyperbolic cotangent of N radians",
        "body": "cothr(${1:number})"
    },
    "floor(an)": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds PYR down to argument 2's decimal precision",
        "body": "floor(${1:angle}, ${2:number})"
    },
    "vec4(xv2xv2)": {
        "scope": "source.e2",
        "prefix": "vec4",
        "description": "Creates a 4D vector from two 2D vectors",
        "body": "vec4(${1:vector2}, ${2:vector2})"
    },
    "findClearWhiteEntityList": {
        "scope": "source.e2",
        "prefix": "findClearWhiteEntityList",
        "description": "Clear all entries from the player whitelist",
        "body": "findClearWhiteEntityList()"
    },
    "vonEncode": {
        "scope": "source.e2",
        "prefix": "vonEncode",
        "description": "Encodes an array into a string using vON",
        "body": "vonEncode(${1:array})"
    },
    "writeUnicodeString(snnnnn)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snnnn), with an extra argument for flashing text. 0 or 1 is recommended",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:number}, ${5:number}, ${6:number})"
    },
    "writeString(snnvn)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snnv), with an extra argument for background colour. This is in the form of a 3-digit RGB code. 0 is black, while 999 is white, 900 is pure red and so on",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:vector}, ${5:number})"
    },
    "egpScrH": {
        "scope": "source.e2",
        "prefix": "egpScrH",
        "description": "Returns the player's screen resolution height",
        "body": "egpScrH()"
    },
    "isWeldedTo(n)": {
        "scope": "source.e2",
        "prefix": "isWeldedTo",
        "description": "e:isWeldedTo\nReturns the Nth entity E was welded to",
        "body": "isWeldedTo(${1:number})"
    },
    "rangerFilter(r)": {
        "scope": "source.e2",
        "prefix": "rangerFilter",
        "description": "Feed an array of entities you don't want the trace to hit",
        "body": "rangerFilter(${1:array})"
    },
    "minIndex": {
        "scope": "source.e2",
        "prefix": "minIndex",
        "description": "t:minIndex\nReturns the index of the smallest numerical entry in the array-part",
        "body": "minIndex()"
    },
    "toLocalAxis": {
        "scope": "source.e2",
        "prefix": "toLocalAxis",
        "description": "e:toLocalAxis\nTransforms a world axis to an axis local to E",
        "body": "toLocalAxis(${1:vector})"
    },
    "teamFrags": {
        "scope": "source.e2",
        "prefix": "teamFrags",
        "description": "Returns the number of kills of the team associated with the team number",
        "body": "teamFrags(${1:number})"
    },
    "findInBox": {
        "scope": "source.e2",
        "prefix": "findInBox",
        "description": "Like findInSphere but with a globally aligned box, the arguments are the diagonal corners of the box",
        "body": "findInBox(${1:vector}, ${2:vector})"
    },
    "soundPlay(nnsn)": {
        "scope": "source.e2",
        "prefix": "soundPlay",
        "description": "e:soundPlay\nPlays sound from an entity. soundPlay(int Index, int Duration, string Path to File, int FadeTime)",
        "body": "soundPlay(${1:number}, ${2:number}, ${3:string}, ${4:number})"
    },
    "holoVisible(nrn)": {
        "scope": "source.e2",
        "prefix": "holoVisible",
        "description": "If 0, prevents an array of players from seeing the hologram",
        "body": "holoVisible(${1:number}, ${2:array}, ${3:number})"
    },
    "steamIDFrom64": {
        "scope": "source.e2",
        "prefix": "steamIDFrom64",
        "description": "Converts Steam Community ID to Steam ID",
        "body": "steamIDFrom64(${1:string})"
    },
    "jsonEncode": {
        "scope": "source.e2",
        "prefix": "jsonEncode",
        "description": "Encodes an array into a string using json",
        "body": "jsonEncode(${1:array})"
    },
    "getTimers": {
        "scope": "source.e2",
        "prefix": "getTimers",
        "description": "Returns an array of all timers used in the E2",
        "body": "getTimers()"
    },
    "fileListClk()": {
        "scope": "source.e2",
        "prefix": "fileListClk",
        "description": "Returns whether the execution was run because a list was uploaded to the server",
        "body": "fileListClk()"
    },
    "startSolid": {
        "scope": "source.e2",
        "prefix": "startSolid",
        "description": "xrd:startSolid\nReturns 1 if the trace was started inside the world, else 0",
        "body": "startSolid()"
    },
    "attachmentPos": {
        "scope": "source.e2",
        "prefix": "attachmentPos",
        "description": "e:attachmentPos\nReturns Es attachment position associated with attachmentID",
        "body": "attachmentPos(${1:number})"
    },
    "attachmentAng(s)": {
        "scope": "source.e2",
        "prefix": "attachmentAng",
        "description": "e:attachmentAng\nSame as E:attachmentAng(E:lookupAttachment(attachmentName))",
        "body": "attachmentAng(${1:string})"
    },
    "printColor": {
        "scope": "source.e2",
        "prefix": "printColor",
        "description": "Works like chat.AddText(...). Parameters can be any amount and combination of numbers, strings, player entities, color vectors (both 3D and 4D)",
        "body": "printColor(${1:....})"
    },
    "httpRequestUrl": {
        "scope": "source.e2",
        "prefix": "httpRequestUrl",
        "description": "Returns the URL of the last request",
        "body": "httpRequestUrl()"
    },
    "holoEntity": {
        "scope": "source.e2",
        "prefix": "holoEntity",
        "description": "Returns the entity corresponding to the hologram given by the specified index",
        "body": "holoEntity(${1:number})"
    },
    "npcAttack": {
        "scope": "source.e2",
        "prefix": "npcAttack",
        "description": "e:npcAttack\nTells the NPC to use their melee attack",
        "body": "npcAttack()"
    },
    "typeidsArray": {
        "scope": "source.e2",
        "prefix": "typeidsArray",
        "description": "t:typeidsArray\nReturns an array with the typeids of the array-part of the table",
        "body": "typeidsArray()"
    },
    "wirelink": {
        "scope": "source.e2",
        "prefix": "wirelink",
        "description": "Returns wirelink to this E2",
        "body": "wirelink()"
    },
    "swapElements": {
        "scope": "source.e2",
        "prefix": "swapElements",
        "description": "xm2:swapElements\nSwaps two elements, specified by indices ( i1, j1, i2, j2 )",
        "body": "swapElements(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "findMax": {
        "scope": "source.e2",
        "prefix": "findMax",
        "description": "Returns the maximum number of finds per E2",
        "body": "findMax()"
    },
    "minFrictionMass": {
        "scope": "source.e2",
        "prefix": "minFrictionMass",
        "description": "Returns how much friction influences props throughout the server",
        "body": "minFrictionMass()"
    },
    "egpAngle": {
        "scope": "source.e2",
        "prefix": "egpAngle",
        "description": "xwl:egpAngle\nChanges the angle of the object",
        "body": "egpAngle(${1:number}, ${2:number})"
    },
    "holoAng": {
        "scope": "source.e2",
        "prefix": "holoAng",
        "description": "Sets the angle of the hologram",
        "body": "holoAng(${1:number}, ${2:angle})"
    },
    "toString(xv2)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Gets the vector nicely formatted as a string \"[X,Y]",
        "body": "toString(${1:vector2})"
    },
    "transpose(xm4)": {
        "scope": "source.e2",
        "prefix": "transpose",
        "description": "Returns the transpose of a matrix",
        "body": "transpose(${3:vector4})"
    },
    "runOnPlayerDisconnect": {
        "scope": "source.e2",
        "prefix": "runOnPlayerDisconnect",
        "description": "If set to 0, the chip will no longer run on player disconnect events, otherwise it makes this chip execute when someone disconnects. Only needs to be called once, not in every execution",
        "body": "runOnPlayerDisconnect(${1:number})"
    },
    "egpLineStrip": {
        "scope": "source.e2",
        "prefix": "egpLineStrip",
        "description": "xwl:egpLineStrip\nCreates a curve with specified points as 2D/4D vectors (x,y)/(x,y,u,v)",
        "body": "egpLineStrip(${1:n...})"
    },
    "lastSaidTeam": {
        "scope": "source.e2",
        "prefix": "lastSaidTeam",
        "description": "Returns 1 if the last message was sent in the team chat, 0 otherwise",
        "body": "lastSaidTeam()"
    },
    "weapons": {
        "scope": "source.e2",
        "prefix": "weapons",
        "description": "e:weapons\nReturns the weapons that player E has",
        "body": "weapons()"
    },
    "last": {
        "scope": "source.e2",
        "prefix": "last",
        "description": "Returns 1 if it is being called on the last execution of the expression gate before it is removed or reset. This execution must be requested with the runOnLast(1) command",
        "body": "last()"
    },
    "parent": {
        "scope": "source.e2",
        "prefix": "parent",
        "description": "e:parent\nReturns the entity E is parented to",
        "body": "parent()"
    },
    "findRE(sn)": {
        "scope": "source.e2",
        "prefix": "findRE",
        "description": "s:findRE\nReturns the 1st occurrence of the string S starting at N and going to the end of the string using REGEX functions, returns 0 if not found",
        "body": "findRE(${1:string}, ${2:number})"
    },
    "hintDriver": {
        "scope": "source.e2",
        "prefix": "hintDriver",
        "description": "e:hintDriver\nDisplays a hint popup to the driver of vehicle E, with message S for N seconds (N being clamped between 0.7 and 7). Same return value as printDriver",
        "body": "hintDriver(${1:string}, ${2:number})"
    },
    "rangerHull(nnnvv)": {
        "scope": "source.e2",
        "prefix": "rangerHull",
        "description": "Inputs: Distance, X Skew, Y Skew, Hull MinSize, Hull MaxSize",
        "body": "rangerHull(${1:number}, ${2:number}, ${3:number}, ${4:vector}, ${5:vector})"
    },
    "keyForward": {
        "scope": "source.e2",
        "prefix": "keyForward",
        "description": "e:keyForward\nIs the player pressing their forward key? (default W)",
        "body": "keyForward()"
    },
    "holoUnparent": {
        "scope": "source.e2",
        "prefix": "holoUnparent",
        "description": "Un-parents the hologram",
        "body": "holoUnparent(${1:number})"
    },
    "holoParentAttachment": {
        "scope": "source.e2",
        "prefix": "holoParentAttachment",
        "description": "Parents the hologram to an entity's bone by its attachment name",
        "body": "holoParentAttachment(${1:number}, ${3:string})"
    },
    "ejectPod": {
        "scope": "source.e2",
        "prefix": "ejectPod",
        "description": "e:ejectPod\nEjects player in vehicle",
        "body": "ejectPod()"
    },
    "friends": {
        "scope": "source.e2",
        "prefix": "friends",
        "description": "e:friends\nReturns an array of players on the prop protection friends list",
        "body": "friends()"
    },
    "sinh": {
        "scope": "source.e2",
        "prefix": "sinh",
        "description": "Returns the hyperbolic sine of N degrees",
        "body": "sinh(${1:number})"
    },
    "hitTexture": {
        "scope": "source.e2",
        "prefix": "hitTexture",
        "description": "xrd:hitTexture\nReturns the texture of the surface the ranger is pointed at",
        "body": "hitTexture()"
    },
    "findClipToEntity": {
        "scope": "source.e2",
        "prefix": "findClipToEntity",
        "description": "Filters the list of entities by removing all except this entity",
        "body": "findClipToEntity()"
    },
    "vec(a)": {
        "scope": "source.e2",
        "prefix": "vec",
        "description": "Changes an angle variable into a vector variable. PYR become XYZ respectively",
        "body": "vec(${1:angle})"
    },
    "findPlayerByName": {
        "scope": "source.e2",
        "prefix": "findPlayerByName",
        "description": "Returns the player with the given name, this is an exception to the rule",
        "body": "findPlayerByName(${1:string})"
    },
    "npcGoRun": {
        "scope": "source.e2",
        "prefix": "npcGoRun",
        "description": "e:npcGoRun\nTells the NPC to run to position V",
        "body": "npcGoRun(${1:vector})"
    },
    "ang()": {
        "scope": "source.e2",
        "prefix": "ang",
        "description": "Same as ang(0,0,0)",
        "body": "ang()"
    },
    "matrix4": {
        "scope": "source.e2",
        "prefix": "matrix4",
        "description": "Creates a 4x4 zero matrix",
        "body": "matrix4()"
    },
    "ang": {
        "scope": "source.e2",
        "prefix": "ang",
        "description": "Makes an angle",
        "body": "ang(${1:number})"
    },
    "dot(xv4)": {
        "scope": "source.e2",
        "prefix": "dot",
        "description": "xv4:dot\nGets the 4D vector dot (scalar) product",
        "body": "dot(${1:vector4})"
    },
    "matrix2": {
        "scope": "source.e2",
        "prefix": "matrix2",
        "description": "Creates a 2x2 zero matrix",
        "body": "matrix2()"
    },
    "setColor(v)": {
        "scope": "source.e2",
        "prefix": "setColor",
        "description": "e:setColor\nSets the color of the entity",
        "body": "setColor(${1:vector})"
    },
    "toWorld(a)": {
        "scope": "source.e2",
        "prefix": "toWorld",
        "description": "e:toWorld\nTransforms from an angle local to E to a world angle",
        "body": "toWorld(${1:angle})"
    },
    "\n\"finite": {
        "scope": "source.e2",
        "prefix": "\n\"finite",
        "description": "Returns 1 if given value is a finite number; otherwise 0.",
        "body": "\n\"finite(${1:number})"
    },
    "sqrt": {
        "scope": "source.e2",
        "prefix": "sqrt",
        "description": "Returns the Square Root of the Argument",
        "body": "sqrt(${1:number})"
    },
    "findIncludePlayer(e)": {
        "scope": "source.e2",
        "prefix": "findIncludePlayer",
        "description": "Include specified player in future finds, and remove other entities not in the entity whitelist",
        "body": "findIncludePlayer()"
    },
    "randvec2": {
        "scope": "source.e2",
        "prefix": "randvec2",
        "description": "Returns a uniformly distributed, random, normalized direction vector",
        "body": "randvec2()"
    },
    "getConnectedEntities": {
        "scope": "source.e2",
        "prefix": "getConnectedEntities",
        "description": "e:getConnectedEntities\nReturns an array with all entities directly or indirectly constrained or parented to E, including E itself.",
        "body": "getConnectedEntities(${1:....})"
    },
    "egpWedge": {
        "scope": "source.e2",
        "prefix": "egpWedge",
        "description": "xwl:egpWedge\nCreates a wedge object. Wedge objects are like circles, except they have a cake-piece-like mouth which you can change using egpSize",
        "body": "egpWedge(${1:number}, ${2:vector2}, ${3:vector2})"
    },
    "applyForce(v)": {
        "scope": "source.e2",
        "prefix": "applyForce",
        "description": "b:applyForce\nApplies force to the bone according to the given vector's direction and magnitude",
        "body": "applyForce(${1:vector})"
    },
    "toWorld(vava)": {
        "scope": "source.e2",
        "prefix": "toWorld",
        "description": "Converts a local position/angle to a world position/angle and returns the position",
        "body": "toWorld(${1:vector}, ${2:angle}, ${3:vector}, ${4:angle})"
    },
    "x": {
        "scope": "source.e2",
        "prefix": "x",
        "description": "xv2:x\nGets the x component of the vector",
        "body": "x()"
    },
    "invert": {
        "scope": "source.e2",
        "prefix": "invert",
        "description": "Inverts the table, creating a lookup table",
        "body": "invert(${1:table})"
    },
    "printColorDriver(r)": {
        "scope": "source.e2",
        "prefix": "printColorDriver",
        "description": "e:printColorDriver\nLike printColorDriver but takes an array containing all the parameters",
        "body": "printColorDriver(${1:array})"
    },
    "holoDeleteAll": {
        "scope": "source.e2",
        "prefix": "holoDeleteAll",
        "description": "Removes all holograms made by this E2",
        "body": "holoDeleteAll()"
    },
    "upper": {
        "scope": "source.e2",
        "prefix": "upper",
        "description": "s:upper\nAll characters are made uppercase",
        "body": "upper()"
    },
    "applyOffsetForce(vv)": {
        "scope": "source.e2",
        "prefix": "applyOffsetForce",
        "description": "b:applyOffsetForce\nApplies force to the bone according to the first vector from the location of the second",
        "body": "applyOffsetForce(${1:vector}, ${2:vector})"
    },
    "intersect": {
        "scope": "source.e2",
        "prefix": "intersect",
        "description": "t:intersect\nRemoves all variables with keys which don't exist in T2",
        "body": "intersect(${1:table})"
    },
    "egpRadius(n)": {
        "scope": "source.e2",
        "prefix": "egpRadius",
        "description": "xwl:egpRadius\nReturns the corcner radius of the rounded box object",
        "body": "egpRadius(${1:number})"
    },
    "matrix(xm4)": {
        "scope": "source.e2",
        "prefix": "matrix",
        "description": "Converts a 4x4 matrix into a 3x3 matrix - all (i,4) and (4,j) are omitted",
        "body": "matrix(${3:vector4})"
    },
    "jsonEncodeExternal(tn)": {
        "scope": "source.e2",
        "prefix": "jsonEncodeExternal",
        "description": "Encodes a table into a string using json, in a form that is suitable to be exported to external resources. Unfortunately, arrays are ignored because E2 contains many ambiguous types, and arrays don't keep track of those types. You will have to convert your array to a table manually before encoding it.",
        "body": "jsonEncodeExternal(${1:table}, ${2:number})"
    },
    "egpTriangleOutline": {
        "scope": "source.e2",
        "prefix": "egpTriangleOutline",
        "description": "xwl:egpTriangleOutline\nCreates a outline triangle with specified vertices",
        "body": "egpTriangleOutline(${1:number}, ${2:vector2}, ${3:vector2}, ${4:vector2})"
    },
    "inverseA": {
        "scope": "source.e2",
        "prefix": "inverseA",
        "description": "Finds the matrix inverse of a standard 4x4 affine transformation matrix ( the type created by matrix4(E) ). This should only be used on matrices with a particular format, where the top left 3x3 specifies rotation, the rightmost 3-column specifies translation, and the bottom row is (0,0,0,1)",
        "body": "inverseA(${3:vector4})"
    },
    "concat(nn)": {
        "scope": "source.e2",
        "prefix": "concat",
        "description": "r:concat\nConcatenates all values in the array, starting at index N1 and ending at N2",
        "body": "concat(${1:number}, ${2:number})"
    },
    "dsSend": {
        "scope": "source.e2",
        "prefix": "dsSend",
        "description": "Sends a datasignal to the specified group and scope",
        "body": "dsSend()"
    },
    "teams": {
        "scope": "source.e2",
        "prefix": "teams",
        "description": "Returns an array of all teams",
        "body": "teams()"
    },
    "setRenderMode": {
        "scope": "source.e2",
        "prefix": "setRenderMode",
        "description": "e:setRenderMode\nSets the render mode of the entity (0 = Normal, 1 = TransColor, 2 = TransTexture, 3 = Glow, 4 = TransAlpha, 5 = TransAdd, 6 = Enviromental, 7 = TransAddFrameBlend, 8 = TransAlphaAdd, 9 = WorldGlow, 10 = None)",
        "body": "setRenderMode(${1:number})"
    },
    "printDriver(ns)": {
        "scope": "source.e2",
        "prefix": "printDriver",
        "description": "e:printDriver\nSame as EE:printDriver(S), but can make the text show up in different places. N can be one of the following: _HUD_PRINTCENTER, _HUD_PRINTCONSOLE, _HUD_PRINTNOTIFY, _HUD_PRINTTALK",
        "body": "printDriver(${1:number}, ${2:string})"
    },
    "atanr(nn)": {
        "scope": "source.e2",
        "prefix": "atanr",
        "description": "Returns the inverse tangent of the arguments (arg1 / arg2), in radians. This function accounts for positive/negative arguments, and arguments at or close to 0",
        "body": "atanr(${1:number}, ${2:number})"
    },
    "bOr": {
        "scope": "source.e2",
        "prefix": "bOr",
        "description": "Performs bitwise OR against the two numbers",
        "body": "bOr(${1:number}, ${2:number})"
    },
    "round(xv2n)": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds XY to argument 2's decimal precision",
        "body": "round(${1:vector2}, ${2:number})"
    },
    "gamemode": {
        "scope": "source.e2",
        "prefix": "gamemode",
        "description": "Returns the name of the current gamemode",
        "body": "gamemode()"
    },
    "rowMatrix": {
        "scope": "source.e2",
        "prefix": "rowMatrix",
        "description": "Creates a 3x3 matrix with vectors by rows",
        "body": "rowMatrix(${1:vector}, ${2:vector}, ${3:vector})"
    },
    "weapon": {
        "scope": "source.e2",
        "prefix": "weapon",
        "description": "e:weapon\nReturns the weapon with specified class of player E",
        "body": "weapon(${1:string})"
    },
    "fileLoading": {
        "scope": "source.e2",
        "prefix": "fileLoading",
        "description": "Returns whether a file is currently uploading",
        "body": "fileLoading()"
    },
    "bNot": {
        "scope": "source.e2",
        "prefix": "bNot",
        "description": "Performs a binary Not",
        "body": "bNot(${1:number})"
    },
    "hsl2rgb": {
        "scope": "source.e2",
        "prefix": "hsl2rgb",
        "description": "Converts V from the HSL color space to the RGB color space",
        "body": "hsl2rgb(${1:vector})"
    },
    "signalSendDirect": {
        "scope": "source.e2",
        "prefix": "signalSendDirect",
        "description": "Sends signal S to the given chip. Multiple calls for different chips do not overwrite each other",
        "body": "signalSendDirect(${1:string})"
    },
    "findPlayerUpdateRate": {
        "scope": "source.e2",
        "prefix": "findPlayerUpdateRate",
        "description": "Returns the minimum delay between entity find events per player",
        "body": "findPlayerUpdateRate()"
    },
    "toDeg": {
        "scope": "source.e2",
        "prefix": "toDeg",
        "description": "Converts Radian angles to Degree angles",
        "body": "toDeg(${1:number})"
    },
    "getCodeIncludes": {
        "scope": "source.e2",
        "prefix": "getCodeIncludes",
        "description": "Returns a table where indices (keys) are names of included files and entries are their codes",
        "body": "getCodeIncludes()"
    },
    "dsGetType": {
        "scope": "source.e2",
        "prefix": "dsGetType",
        "description": "Returns the type of the received data",
        "body": "dsGetType()"
    },
    "findClearBlackPlayerPropList": {
        "scope": "source.e2",
        "prefix": "findClearBlackPlayerPropList",
        "description": "Clear all entries from the prop owner blacklist",
        "body": "findClearBlackPlayerPropList()"
    },
    "vec(xv4)": {
        "scope": "source.e2",
        "prefix": "vec",
        "description": "Converts a 4D vector into a 3D vector (the w component is dropped)",
        "body": "vec(${1:vector4})"
    },
    "keyAttack2": {
        "scope": "source.e2",
        "prefix": "keyAttack2",
        "description": "e:keyAttack2\nIs the player pressing their secondary fire key?",
        "body": "keyAttack2()"
    },
    "qi(n)": {
        "scope": "source.e2",
        "prefix": "qi",
        "description": "Returns quaternion N*i",
        "body": "qi(${1:number})"
    },
    "randvec4(nn)": {
        "scope": "source.e2",
        "prefix": "randvec4",
        "description": "Returns a random vector with its components between N1 and N2",
        "body": "randvec4(${1:number}, ${2:number})"
    },
    "setColumn(nnnn)": {
        "scope": "source.e2",
        "prefix": "setColumn",
        "description": "m:setColumn\nSets the values of a column. The first argument given specifies the column(i), the following arguments are the values i1, i2, i3",
        "body": "setColumn(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "bShr": {
        "scope": "source.e2",
        "prefix": "bShr",
        "description": "Performs bitwise shift right on the first number by the amount of the second",
        "body": "bShr(${1:number}, ${2:number})"
    },
    "dsGetHash": {
        "scope": "source.e2",
        "prefix": "dsGetHash",
        "description": "Returns the hash of sending E2",
        "body": "dsGetHash()"
    },
    "coshr": {
        "scope": "source.e2",
        "prefix": "coshr",
        "description": "Returns the hyperbolic cosine of N radians",
        "body": "coshr(${1:number})"
    },
    "angles": {
        "scope": "source.e2",
        "prefix": "angles",
        "description": "e:angles\nGets the pitch, yaw and roll of the entity",
        "body": "angles()"
    },
    "tickClk": {
        "scope": "source.e2",
        "prefix": "tickClk",
        "description": "Returns 1 if the current execution was caused by \"runOnTick",
        "body": "tickClk()"
    },
    "shiftR(a)": {
        "scope": "source.e2",
        "prefix": "shiftR",
        "description": "Shifts the angle's components right: shiftR( p,y,r ) = ( r,p,y )",
        "body": "shiftR(${1:angle})"
    },
    "egpRoundedBox": {
        "scope": "source.e2",
        "prefix": "egpRoundedBox",
        "description": "xwl:egpRoundedBox\nCreates a rounded box. First 2D vector is the position, second is size",
        "body": "egpRoundedBox(${1:number}, ${2:vector2}, ${3:vector2})"
    },
    "holoBoneScale(nnv)": {
        "scope": "source.e2",
        "prefix": "holoBoneScale",
        "description": "Sets the scale of the given hologram bone, as a multiplier",
        "body": "holoBoneScale(${1:number}, ${2:number}, ${3:vector})"
    },
    "toString(v)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Gets the vector nicely formatted as a string \"[X,Y,Z]",
        "body": "toString(${1:vector})"
    },
    "outputs": {
        "scope": "source.e2",
        "prefix": "outputs",
        "description": "xwl:outputs\nReturns an array of all the outputs that XWL has without their types. Returns an empty array if it has none",
        "body": "outputs()"
    },
    "signalSendToPlayer": {
        "scope": "source.e2",
        "prefix": "signalSendToPlayer",
        "description": "Sends signal S to chips owned by the given player, multiple calls for different players do not overwrite each other",
        "body": "signalSendToPlayer(${1:string})"
    },
    "runOnKeys": {
        "scope": "source.e2",
        "prefix": "runOnKeys",
        "description": "If set to 1, E2 will run when specified player presses/releases their key",
        "body": "runOnKeys(${2:number})"
    },
    "holoMaterial": {
        "scope": "source.e2",
        "prefix": "holoMaterial",
        "description": "Sets the overlay material of the hologram",
        "body": "holoMaterial(${1:number}, ${2:string})"
    },
    "massCenter()": {
        "scope": "source.e2",
        "prefix": "massCenter",
        "description": "b:massCenter\nReturns Bs Center of Mass",
        "body": "massCenter()"
    },
    "egpColor": {
        "scope": "source.e2",
        "prefix": "egpColor",
        "description": "xwl:egpColor\nReturns the color of the object as 3D vector",
        "body": "egpColor(${1:number})"
    },
    "egpDrawTopLeft": {
        "scope": "source.e2",
        "prefix": "egpDrawTopLeft",
        "description": "xwl:egpDrawTopLeft\nSet to 1 to make boxes, outline boxes, rounded boxes, and rounded outline boxes draw from the top left corner instead of from the center",
        "body": "egpDrawTopLeft(${1:number})"
    },
    "writeUnicodeString(snnvnn)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snnvn), with an extra argument for flashing text. 0 or 1 is recommended",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:vector}, ${5:number}, ${6:number})"
    },
    "soundStop": {
        "scope": "source.e2",
        "prefix": "soundStop",
        "description": "Stops the sound stored at the integer index and removes the entry",
        "body": "soundStop(${1:number})"
    },
    "egpCircleOutline": {
        "scope": "source.e2",
        "prefix": "egpCircleOutline",
        "description": "xwl:egpCircleOutline\nCreates an outline circle. First 2D vector is the position, second is size",
        "body": "egpCircleOutline(${1:number}, ${2:vector2}, ${3:vector2})"
    },
    "ceil(v)": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds XYZ up to the nearest integer",
        "body": "ceil(${1:vector})"
    },
    "int": {
        "scope": "source.e2",
        "prefix": "int",
        "description": "Returns the Integer part of the Argument (same as floor)",
        "body": "int(${1:number})"
    },
    "npcRelationship": {
        "scope": "source.e2",
        "prefix": "npcRelationship",
        "description": "e:npcRelationship\nWill set the NPC's relationship to the specified entity to the S input, priority N. Priority is any number between 0 and 999. The relationship string can be either \"like\", \"neutral\", \"hate\" or \"fear\". Same goes for all other relationship functions",
        "body": "npcRelationship(${2:string}, ${3:number})"
    },
    "sech": {
        "scope": "source.e2",
        "prefix": "sech",
        "description": "Returns the hyperbolic secant of N degrees",
        "body": "sech(${1:number})"
    },
    "applyOffsetForce": {
        "scope": "source.e2",
        "prefix": "applyOffsetForce",
        "description": "Applies force to the E2 chip according to the first vector from the location of the second",
        "body": "applyOffsetForce(${1:vector}, ${2:vector})"
    },
    "print(...)": {
        "scope": "source.e2",
        "prefix": "print",
        "description": "Prints all arguments to the chat area, seperated by a tab. Automatically does toString for you (Can print arrays but not tables). Works just like lua's print",
        "body": "print(${1:....})"
    },
    "concat(s)": {
        "scope": "source.e2",
        "prefix": "concat",
        "description": "r:concat\nConcatenates all values in the array with the specified string in between each",
        "body": "concat(${1:string})"
    },
    "dsClk": {
        "scope": "source.e2",
        "prefix": "dsClk",
        "description": "Returns 1 if the current execution was caused by a datasignal",
        "body": "dsClk()"
    },
    "getConstraints": {
        "scope": "source.e2",
        "prefix": "getConstraints",
        "description": "e:getConstraints\nReturns an array with all entities directly or indirectly constrained to E, except E itself. Deprecated, use E:getConnectedEntities(...) instead.",
        "body": "getConstraints()"
    },
    "getCodeIncludes()": {
        "scope": "source.e2",
        "prefix": "getCodeIncludes",
        "description": "Returns a table where indices (keys) are names of included files and entries are their codes",
        "body": "getCodeIncludes()"
    },
    "csqrt": {
        "scope": "source.e2",
        "prefix": "csqrt",
        "description": "Calculates the complex square root of the real number N",
        "body": "csqrt(${1:number})"
    },
    "creationTime": {
        "scope": "source.e2",
        "prefix": "creationTime",
        "description": "e:creationTime\nReturns the time the entity was created on, relative to curtime.",
        "body": "creationTime()"
    },
    "dsLeaveGroup": {
        "scope": "source.e2",
        "prefix": "dsLeaveGroup",
        "description": "Leave the group to stop receiving signals from it",
        "body": "dsLeaveGroup(${1:string})"
    },
    "glonEncode": {
        "scope": "source.e2",
        "prefix": "glonEncode",
        "description": "Encodes an array into a string using GLON",
        "body": "glonEncode(${1:array})"
    },
    "inGodMode": {
        "scope": "source.e2",
        "prefix": "inGodMode",
        "description": "e:inGodMode\nReturns whether the player has god mode or not",
        "body": "inGodMode()"
    },
    "swapRows()": {
        "scope": "source.e2",
        "prefix": "swapRows",
        "description": "xm2:swapRows\nSwaps rows",
        "body": "swapRows()"
    },
    "aimNormal": {
        "scope": "source.e2",
        "prefix": "aimNormal",
        "description": "e:aimNormal\nReturns a normalized directional vector perpendicular to the surface pointed at",
        "body": "aimNormal()"
    },
    "driver": {
        "scope": "source.e2",
        "prefix": "driver",
        "description": "e:driver\nReturns the driver of the vehicle if there is one, nil otherwise",
        "body": "driver()"
    },
    "up": {
        "scope": "source.e2",
        "prefix": "up",
        "description": "e:up\nGets the up direction of the entity",
        "body": "up()"
    },
    "writeString(snnvvn)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snnvv), with an extra argument for flashing text. 0 or 1 is recommended",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:vector}, ${5:vector}, ${6:number})"
    },
    "holoParent": {
        "scope": "source.e2",
        "prefix": "holoParent",
        "description": "Parents the hologram to an entity",
        "body": "holoParent(${1:number})"
    },
    "min(vv)": {
        "scope": "source.e2",
        "prefix": "min",
        "description": "Returns the vector with the smallest length",
        "body": "min(${1:vector}, ${2:vector})"
    },
    "pointContentsArray": {
        "scope": "source.e2",
        "prefix": "pointContentsArray",
        "description": "Returns an array with all the \"content\" types in the vector point",
        "body": "pointContentsArray(${1:vector})"
    },
    "comp": {
        "scope": "source.e2",
        "prefix": "comp",
        "description": "Returns complex zero",
        "body": "comp()"
    },
    "egpQueuePlayer": {
        "scope": "source.e2",
        "prefix": "egpQueuePlayer",
        "description": "Returns the player which ordered the items to be sent",
        "body": "egpQueuePlayer()"
    },
    "egpClear": {
        "scope": "source.e2",
        "prefix": "egpClear",
        "description": "xwl:egpClear\nClears the EGP screen",
        "body": "egpClear()"
    },
    "keyJump": {
        "scope": "source.e2",
        "prefix": "keyJump",
        "description": "e:keyJump\nIs the player pressing their jump key?",
        "body": "keyJump()"
    },
    "clamp(xv4nn)": {
        "scope": "source.e2",
        "prefix": "clamp",
        "description": "Returns a vector in the same direction as vector 1, with length clamped between argument 2(min) and argument 3(max)",
        "body": "clamp(${1:vector4}, ${2:number}, ${3:number})"
    },
    "egpQueueScreenWirelink": {
        "scope": "source.e2",
        "prefix": "egpQueueScreenWirelink",
        "description": "Returns the screen wirelink which the queue finished sending items for",
        "body": "egpQueueScreenWirelink()"
    },
    "egpQueueClk()": {
        "scope": "source.e2",
        "prefix": "egpQueueClk",
        "description": "Returns 1 if the current execution was caused by the EGP queue system",
        "body": "egpQueueClk()"
    },
    "z": {
        "scope": "source.e2",
        "prefix": "z",
        "description": "v:z\nGets the z component of the vector",
        "body": "z()"
    },
    "comp(n)": {
        "scope": "source.e2",
        "prefix": "comp",
        "description": "Converts a real number to complex (returns complex number with real part N and imaginary part 0)",
        "body": "comp(${1:number})"
    },
    "rotationAxis": {
        "scope": "source.e2",
        "prefix": "rotationAxis",
        "description": "Returns the axis of rotation (by coder0xff)",
        "body": "rotationAxis()"
    },
    "isConstrainedTo(n)": {
        "scope": "source.e2",
        "prefix": "isConstrainedTo",
        "description": "e:isConstrainedTo\nReturns the Nth entity E was constrained to",
        "body": "isConstrainedTo(${1:number})"
    },
    "jsonEncode(tn)": {
        "scope": "source.e2",
        "prefix": "jsonEncode",
        "description": "Encodes a table into a string using json",
        "body": "jsonEncode(${1:table}, ${2:number})"
    },
    "massCenterL": {
        "scope": "source.e2",
        "prefix": "massCenterL",
        "description": "e:massCenterL\nGets the center of mass as a local vector",
        "body": "massCenterL()"
    },
    "positive(v)": {
        "scope": "source.e2",
        "prefix": "positive",
        "description": "Returns a vector containing the positive value of each vector component, equivalent to abs(N)",
        "body": "positive(${1:vector})"
    },
    "getSkinCount": {
        "scope": "source.e2",
        "prefix": "getSkinCount",
        "description": "e:getSkinCount\nGets Es number of skins",
        "body": "getSkinCount()"
    },
    "secr": {
        "scope": "source.e2",
        "prefix": "secr",
        "description": "Returns the secant of N radians",
        "body": "secr(${1:number})"
    },
    "egpSetText": {
        "scope": "source.e2",
        "prefix": "egpSetText",
        "description": "xwl:egpSetText\nChanges the text of the text object",
        "body": "egpSetText(${1:number}, ${2:string})"
    },
    "realtime": {
        "scope": "source.e2",
        "prefix": "realtime",
        "description": "Returns the current real time since server-start in seconds",
        "body": "realtime()"
    },
    "writeUnicodeString(snnn)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snn), with an extra argument for the text colour. This is in the form of a 3-digit RGB code. 0 is black, while 999 is white, 900 is pure red and so on",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:number})"
    },
    "minquota": {
        "scope": "source.e2",
        "prefix": "minquota",
        "description": "The ops left before soft quota is used up",
        "body": "minquota()"
    },
    "writeString(snnvv)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snnv), with an extra argument for background colour",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:vector}, ${5:vector})"
    },
    "type": {
        "scope": "source.e2",
        "prefix": "type",
        "description": "e:type\nGets the class of an entity",
        "body": "type()"
    },
    "printDriver": {
        "scope": "source.e2",
        "prefix": "printDriver",
        "description": "e:printDriver\nPosts a string to the chat of Es driver. Returns 1 if the text was printed, 0 if not",
        "body": "printDriver(${1:string})"
    },
    "assert(ns)": {
        "scope": "source.e2",
        "prefix": "assert",
        "description": "If the first argument is 0, shut down the E2 with the given error message string",
        "body": "assert(${1:number}, ${2:string})"
    },
    "isFlashlightOn": {
        "scope": "source.e2",
        "prefix": "isFlashlightOn",
        "description": "e:isFlashlightOn\nReturns 1 if the player has flashlight on, 0 otherwise",
        "body": "isFlashlightOn()"
    },
    "setX(n)": {
        "scope": "source.e2",
        "prefix": "setX",
        "description": "xv4:setX\nReturns a copy of the 4D vector with X replaced (use as Vec4 = Vec4:setX(...))",
        "body": "setX(${1:number})"
    },
    "dehomogenized": {
        "scope": "source.e2",
        "prefix": "dehomogenized",
        "description": "v:dehomogenized\nConverts a 2D homogeneous vector (x,y,w) into a 2D cartesian vector",
        "body": "dehomogenized()"
    },
    "setMaterialIndex": {
        "scope": "source.e2",
        "prefix": "setMaterialIndex",
        "description": "xef:setMaterialIndex\nSets the material index of the effect",
        "body": "setMaterialIndex(${1:number})"
    },
    "interval": {
        "scope": "source.e2",
        "prefix": "interval",
        "description": "Sets a one-time timer with name \"interval\" and delay in milliseconds (minimum delay for timers is 10ms)",
        "body": "interval(${1:number})"
    },
    "egpParentToCursor": {
        "scope": "source.e2",
        "prefix": "egpParentToCursor",
        "description": "xwl:egpParentToCursor\nParents the object to player's cursor",
        "body": "egpParentToCursor(${1:number})"
    },
    "typeids": {
        "scope": "source.e2",
        "prefix": "typeids",
        "description": "t:typeids\nReturns a new table with the typeids of the table",
        "body": "typeids()"
    },
    "matrix2(xv2xv2)": {
        "scope": "source.e2",
        "prefix": "matrix2",
        "description": "Creates a matrix with vectors by columns",
        "body": "matrix2(${1:vector2}, ${2:vector2})"
    },
    "chatClk": {
        "scope": "source.e2",
        "prefix": "chatClk",
        "description": "Returns 1 if the chip is being executed because of a chat event. Returns 0 otherwise",
        "body": "chatClk()"
    },
    "writeString(snnnv)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snnn), with an extra argument for background colour",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:number}, ${5:vector})"
    },
    "egpPolyOutline(n...)": {
        "scope": "source.e2",
        "prefix": "egpPolyOutline",
        "description": "xwl:egpPolyOutline\nCreates a outline polygon with specified points as 2D/4D vectors (x,y)/(x,y,u,v)",
        "body": "egpPolyOutline(${1:n...})"
    },
    "setRow": {
        "scope": "source.e2",
        "prefix": "setRow",
        "description": "xm2:setRow\nSets the values of a row. The first argument given specifies the row(j), the following arguments are the values 1j, 2j",
        "body": "setRow(${1:number}, ${2:number}, ${3:number})"
    },
    "holoCreate": {
        "scope": "source.e2",
        "prefix": "holoCreate",
        "description": "Index, Position, Scale, Angle, Color (RGB), Model\nCreates a new hologram entity",
        "body": "holoCreate(${1:number}, ${2:vector}, ${3:vector}, ${4:angle}, ${5:vector}, ${6:string})"
    },
    "swapElements(nnnn)": {
        "scope": "source.e2",
        "prefix": "swapElements",
        "description": "xm4:swapElements\nSwaps two elements, specified by indices ( i1, j1, i2, j2 )",
        "body": "swapElements(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "dsSendDirect": {
        "scope": "source.e2",
        "prefix": "dsSendDirect",
        "description": "Sends a datasignal to the specified E2 (or use an array for several E2s)",
        "body": "dsSendDirect()"
    },
    "dupefinished": {
        "scope": "source.e2",
        "prefix": "dupefinished",
        "description": "Returns 1 when the contraption has finished duping.",
        "body": "dupefinished()"
    },
    "opcounter": {
        "scope": "source.e2",
        "prefix": "opcounter",
        "description": "Returns how many ops have been used so far in this execution plus the amount of hard quota used",
        "body": "opcounter()"
    },
    "pitch": {
        "scope": "source.e2",
        "prefix": "pitch",
        "description": "a:pitch\nGets the pitch of the angle",
        "body": "pitch()"
    },
    "remoteSetCode": {
        "scope": "source.e2",
        "prefix": "remoteSetCode",
        "description": "e:remoteSetCode\nSets the E2's code with main file",
        "body": "remoteSetCode(${1:string})"
    },
    "toUnicodeByte": {
        "scope": "source.e2",
        "prefix": "toUnicodeByte",
        "description": "Returns the Unicode code of the 1st character in the string",
        "body": "toUnicodeByte(${1:string})"
    },
    "egpScrSize": {
        "scope": "source.e2",
        "prefix": "egpScrSize",
        "description": "Returns the player's screen resolution size",
        "body": "egpScrSize()"
    },
    "getCode": {
        "scope": "source.e2",
        "prefix": "getCode",
        "description": "Returns the code of the E2 as a string",
        "body": "getCode()"
    },
    "i": {
        "scope": "source.e2",
        "prefix": "i",
        "description": "Returns the imaginary unit i",
        "body": "i()"
    },
    "mix(xv4xv4n)": {
        "scope": "source.e2",
        "prefix": "mix",
        "description": "Combines vector 1's XYZW with vector 2's XYZW by a proportion given by argument 3 (between 0 and 1)",
        "body": "mix(${1:vector4}, ${2:vector4}, ${3:number})"
    },
    "lastSaidWhen()": {
        "scope": "source.e2",
        "prefix": "lastSaidWhen",
        "description": "e:lastSaidWhen\nReturns when the given player last said something",
        "body": "lastSaidWhen()"
    },
    "applyForce": {
        "scope": "source.e2",
        "prefix": "applyForce",
        "description": "Applies force to the E2 chip according to the given vector's direction and magnitude",
        "body": "applyForce(${1:vector})"
    },
    "soundVolume(nn)": {
        "scope": "source.e2",
        "prefix": "soundVolume",
        "description": "soundVolume(integer Index, Volume), where Volume is a number between 0 and 1. Default Volume is 1",
        "body": "soundVolume(${1:number}, ${2:number})"
    },
    "toUnicodeChar(...)": {
        "scope": "source.e2",
        "prefix": "toUnicodeChar",
        "description": "Returns the UTF-8 string from the given Unicode code-points",
        "body": "toUnicodeChar(${1:....})"
    },
    "real": {
        "scope": "source.e2",
        "prefix": "real",
        "description": "Returns the real part of C",
        "body": "real()"
    },
    "tickInterval": {
        "scope": "source.e2",
        "prefix": "tickInterval",
        "description": "Returns the time (in seconds) between each server tick",
        "body": "tickInterval()"
    },
    "egpParent(nn)": {
        "scope": "source.e2",
        "prefix": "egpParent",
        "description": "xwl:egpParent\nParents the object to another object. Parented objects' positions are local to their parent",
        "body": "egpParent(${1:number}, ${2:number})"
    },
    "npcFace": {
        "scope": "source.e2",
        "prefix": "npcFace",
        "description": "e:npcFace\nThis will rotate the NPC to face position V. This is purely aesthetic and can't be used to aim their weapon",
        "body": "npcFace(${1:vector})"
    },
    "match": {
        "scope": "source.e2",
        "prefix": "match",
        "description": "s:match\nruns string.match(S, S2) and returns the sub-captures as an array",
        "body": "match(${1:string})"
    },
    "outerProduct": {
        "scope": "source.e2",
        "prefix": "outerProduct",
        "description": "v:outerProduct\nGets the outer product (tensor product) and returns a matrix (tensor)",
        "body": "outerProduct(${1:vector})"
    },
    "dehomogenized()": {
        "scope": "source.e2",
        "prefix": "dehomogenized",
        "description": "xv4:dehomogenized\nConverts a 3D homogeneous vector (x,y,z,w) into a 3D cartesian vector",
        "body": "dehomogenized()"
    },
    "egpMaxUmsgPerSecond": {
        "scope": "source.e2",
        "prefix": "egpMaxUmsgPerSecond",
        "description": "Returns the maximum number of usermessages you can send per second",
        "body": "egpMaxUmsgPerSecond()"
    },
    "egpBox": {
        "scope": "source.e2",
        "prefix": "egpBox",
        "description": "xwl:egpBox\nCreates a box. First 2D vector is the position, second is size",
        "body": "egpBox(${1:number}, ${2:vector2}, ${3:vector2})"
    },
    "writeUnicodeString(snn)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nA helper function for using the Wired Console Screen. The unicode string will be written to the screen in white text on black background. The number arguments specify the starting position - X/Horizontal (0-29 recommended) and Y/vertical (0-17)",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number})"
    },
    "time(s)": {
        "scope": "source.e2",
        "prefix": "time",
        "description": "Returns numerical time/date info from the server. Possible arguments: \"year\", \"month\", \"day\", \"hour\", \"min\", \"sec\", \"wday\" (weekday, Sunday is 1), \"yday\" (day of the year), and \"isdst\" (daylight saving flag 0/1)",
        "body": "time(${1:string})"
    },
    "unset(s)": {
        "scope": "source.e2",
        "prefix": "unset",
        "description": "t:unset\nForce removes the specified entry from the table-part, without moving subsequent entries down and returns 1 if removed",
        "body": "unset(${1:string})"
    },
    "log2": {
        "scope": "source.e2",
        "prefix": "log2",
        "description": "Returns the logarithm to base 2 of the Argument",
        "body": "log2(${1:number})"
    },
    "aabbWorldMax": {
        "scope": "source.e2",
        "prefix": "aabbWorldMax",
        "description": "e:aabbWorldMax\nReturns the rotated entity's max world-axis-aligned bounding box corner",
        "body": "aabbWorldMax()"
    },
    "remoteUpload": {
        "scope": "source.e2",
        "prefix": "remoteUpload",
        "description": "e:remoteUpload\nUploads the code from your computer to the server",
        "body": "remoteUpload(${1:string})"
    },
    "fileName": {
        "scope": "source.e2",
        "prefix": "fileName",
        "description": "Returns the name of the last uploaded file, or an empty string if there is no currently uploaded file",
        "body": "fileName()"
    },
    "remove": {
        "scope": "source.e2",
        "prefix": "remove",
        "description": "t:remove\nRemoves the specified entry from the array-part and returns 1 if removed",
        "body": "remove(${1:number})"
    },
    "round(v)": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds XYZ to the nearest integer",
        "body": "round(${1:vector})"
    },
    "acos(c)": {
        "scope": "source.e2",
        "prefix": "acos",
        "description": "Calculates the inverse cosine of C",
        "body": "acos()"
    },
    "typeidsTable": {
        "scope": "source.e2",
        "prefix": "typeidsTable",
        "description": "t:typeidsTable\nReturns a table with the typeids of the table-part of the table",
        "body": "typeidsTable()"
    },
    "holoParent(nb)": {
        "scope": "source.e2",
        "prefix": "holoParent",
        "description": "Parents the hologram to a bone",
        "body": "holoParent(${1:number}, ${2:bone})"
    },
    "matrix(nnnnnnnnn)": {
        "scope": "source.e2",
        "prefix": "matrix",
        "description": "Creates a matrix with 9 values in the following order (i.j): (1,1), (1,2), (1,3), (2,1) etc",
        "body": "matrix(${1:number}, ${2:number}, ${3:number}, ${4:number}, ${5:number}, ${6:number}, ${7:number}, ${8:number}, ${9:number})"
    },
    "steamID": {
        "scope": "source.e2",
        "prefix": "steamID",
        "description": "e:steamID\nGets the steam ID of the player",
        "body": "steamID()"
    },
    "rangerOffsetHull(evv)": {
        "scope": "source.e2",
        "prefix": "rangerOffsetHull",
        "description": "Use entity collision box for the ranger. Inputs: Entity, StartPos, EndPos",
        "body": "rangerOffsetHull(${2:vector}, ${3:vector})"
    },
    "trace(m)": {
        "scope": "source.e2",
        "prefix": "trace",
        "description": "Returns the trace of a matrix",
        "body": "trace()"
    },
    "findExcludeModel": {
        "scope": "source.e2",
        "prefix": "findExcludeModel",
        "description": "Exclude entities with this model (or partial model name) from future finds",
        "body": "findExcludeModel(${1:string})"
    },
    "isLan": {
        "scope": "source.e2",
        "prefix": "isLan",
        "description": "Returns 1 if lan mode is enabled",
        "body": "isLan()"
    },
    "pop": {
        "scope": "source.e2",
        "prefix": "pop",
        "description": "t:pop\nRemoves the last entry in the array-part and returns 1 if removed",
        "body": "pop()"
    },
    "rgb2hsv": {
        "scope": "source.e2",
        "prefix": "rgb2hsv",
        "description": "Converts V from the RGB to the HSV color space",
        "body": "rgb2hsv(${1:vector})"
    },
    "qk": {
        "scope": "source.e2",
        "prefix": "qk",
        "description": "Returns k",
        "body": "qk()"
    },
    "w": {
        "scope": "source.e2",
        "prefix": "w",
        "description": "xv4:w\nGets the w component of the vector",
        "body": "w()"
    },
    "keyWalk": {
        "scope": "source.e2",
        "prefix": "keyWalk",
        "description": "e:keyWalk\nIs the player pressing their walk key?",
        "body": "keyWalk()"
    },
    "findExcludePlayerProps(e)": {
        "scope": "source.e2",
        "prefix": "findExcludePlayerProps",
        "description": "Exclude entities owned by specified player from future finds",
        "body": "findExcludePlayerProps()"
    },
    "asinr": {
        "scope": "source.e2",
        "prefix": "asinr",
        "description": "Returns the inverse sine of the argument, in radians",
        "body": "asinr(${1:number})"
    },
    "setEntity": {
        "scope": "source.e2",
        "prefix": "setEntity",
        "description": "xef:setEntity\nSets the entity of the effect",
        "body": "setEntity()"
    },
    "holoClip(nvvn)": {
        "scope": "source.e2",
        "prefix": "holoClip",
        "description": "Defines a plane used to clip a hologram specified by it's position, direction and number 1/0 whether the position should be global or local to the hologram",
        "body": "holoClip(${1:number}, ${2:vector}, ${3:vector}, ${4:number})"
    },
    "egpQueueClk(xwl)": {
        "scope": "source.e2",
        "prefix": "egpQueueClk",
        "description": "Returns 1 if the current execution was caused by the EGP queue system of specified screen",
        "body": "egpQueueClk(${1:wirelink})"
    },
    "vehicle": {
        "scope": "source.e2",
        "prefix": "vehicle",
        "description": "e:vehicle\nReturns the entity of the vehicle that the specified player is in",
        "body": "vehicle()"
    },
    "pos": {
        "scope": "source.e2",
        "prefix": "pos",
        "description": "e:pos\nGets the position of the entity",
        "body": "pos()"
    },
    "teamName()": {
        "scope": "source.e2",
        "prefix": "teamName",
        "description": "n:teamName\nReturns the name of the team associated with the team number",
        "body": "teamName()"
    },
    "runOnPlayerConnect": {
        "scope": "source.e2",
        "prefix": "runOnPlayerConnect",
        "description": "If set to 0, the chip will no longer run on player connect events, otherwise it makes this chip execute when someone connects. Only needs to be called once, not in every execution",
        "body": "runOnPlayerConnect(${1:number})"
    },
    "angVelVector": {
        "scope": "source.e2",
        "prefix": "angVelVector",
        "description": "e:angVelVector\nReturns rotation axis, velocity and direction given as the vector's direction, magnitude and sense",
        "body": "angVelVector()"
    },
    "real()": {
        "scope": "source.e2",
        "prefix": "real",
        "description": "q:real\nReturns the real component of the quaternion",
        "body": "real()"
    },
    "print": {
        "scope": "source.e2",
        "prefix": "print",
        "description": "Same as print(S), but can make the text show up in different places. N can be one of the following: _HUD_PRINTCENTER, _HUD_PRINTCONSOLE, _HUD_PRINTNOTIFY, _HUD_PRINTTALK",
        "body": "print(${1:number}, ${2:string})"
    },
    "soundPlay(snsn)": {
        "scope": "source.e2",
        "prefix": "soundPlay",
        "description": "e:soundPlay\nPlays sound from an entity. soundPlay(string Index, int Duration, string Path to File, int FadeTime)",
        "body": "soundPlay(${1:string}, ${2:number}, ${3:string}, ${4:number})"
    },
    "httpUrlEncode": {
        "scope": "source.e2",
        "prefix": "httpUrlEncode",
        "description": "Returns formatted string to be placed in the URL",
        "body": "httpUrlEncode(${1:string})"
    },
    "date": {
        "scope": "source.e2",
        "prefix": "date",
        "description": "Returns the server's current time and date",
        "body": "date()"
    },
    "fileCanWrite": {
        "scope": "source.e2",
        "prefix": "fileCanWrite",
        "description": "Returns 1 if the file can be written",
        "body": "fileCanWrite()"
    },
    "boxMin": {
        "scope": "source.e2",
        "prefix": "boxMin",
        "description": "e:boxMin\nGets the minimum local XYZ of the entity's bounding box (the \"lowest\" corner), as a local position vector",
        "body": "boxMin()"
    },
    "diagonal(xm4)": {
        "scope": "source.e2",
        "prefix": "diagonal",
        "description": "Returns a 4D vector comprising the elements along the leading diagonal",
        "body": "diagonal(${3:vector4})"
    },
    "ceil(vn)": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds XYZ up to argument 2's decimal precision",
        "body": "ceil(${1:vector}, ${2:number})"
    },
    "egpObjectIndexes": {
        "scope": "source.e2",
        "prefix": "egpObjectIndexes",
        "description": "xwl:egpObjectIndexes\nReturns an array containing all object indexes being used",
        "body": "egpObjectIndexes()"
    },
    "hideChat": {
        "scope": "source.e2",
        "prefix": "hideChat",
        "description": "Hides the chat messages written by E2 owner",
        "body": "hideChat(${1:number})"
    },
    "pointHasContent": {
        "scope": "source.e2",
        "prefix": "pointHasContent",
        "description": "'S' can be a string containing the last half of the CONTENTS_ enums (ie without the \"CONTENTS_\"). Multiple CONTENTS types can be seperated by a comma. Check: Enumeration_List:Contents for a full list. Examples: \"water,solid\" or \"empty,transparent\". The function returns 1 if any one of the types are found in the vector point",
        "body": "pointHasContent(${1:vector}, ${2:string})"
    },
    "rangerReset": {
        "scope": "source.e2",
        "prefix": "rangerReset",
        "description": "Resets all ranger flags and filters",
        "body": "rangerReset()"
    },
    "isAdmin": {
        "scope": "source.e2",
        "prefix": "isAdmin",
        "description": "e:isAdmin\nIs the player an admin?",
        "body": "isAdmin()"
    },
    "toString(t)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Formats the table as a human-readable string",
        "body": "toString(${1:table})"
    },
    "max(vv)": {
        "scope": "source.e2",
        "prefix": "max",
        "description": "Returns the vector with the greatest length",
        "body": "max(${1:vector}, ${2:vector})"
    },
    "egpQueue": {
        "scope": "source.e2",
        "prefix": "egpQueue",
        "description": "Returns the number of items in your queue",
        "body": "egpQueue()"
    },
    "normalized()": {
        "scope": "source.e2",
        "prefix": "normalized",
        "description": "q:normalized\nReturns new normalized quaternion for Q",
        "body": "normalized()"
    },
    "hostname": {
        "scope": "source.e2",
        "prefix": "hostname",
        "description": "Returns the Name of the server",
        "body": "hostname()"
    },
    "floor(nn)": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds Argument 1 down to Argument 2's decimal precision",
        "body": "floor(${1:number}, ${2:number})"
    },
    "hitSky": {
        "scope": "source.e2",
        "prefix": "hitSky",
        "description": "xrd:hitSky\nReturns 1 if the trace hit the sky, 0 otherwise",
        "body": "hitSky()"
    },
    "signalGroup": {
        "scope": "source.e2",
        "prefix": "signalGroup",
        "description": "Returns the group name of the received signal",
        "body": "signalGroup()"
    },
    "isNPC": {
        "scope": "source.e2",
        "prefix": "isNPC",
        "description": "e:isNPC\nIs the entity a NPC?",
        "body": "isNPC()"
    },
    "tanr": {
        "scope": "source.e2",
        "prefix": "tanr",
        "description": "Returns the tangent of N radians",
        "body": "tanr(${1:number})"
    },
    "ln": {
        "scope": "source.e2",
        "prefix": "ln",
        "description": "Returns the logarithm to base e of the Argument",
        "body": "ln(${1:number})"
    },
    "egpPos(nxv2)": {
        "scope": "source.e2",
        "prefix": "egpPos",
        "description": "xwl:egpPos\nChanges the position of the object",
        "body": "egpPos(${1:number}, ${2:vector2})"
    },
    "runOnFile": {
        "scope": "source.e2",
        "prefix": "runOnFile",
        "description": "Specifies whether the E2 will run when a file finishes uploading",
        "body": "runOnFile(${1:number})"
    },
    "rangerOffset(nvv)": {
        "scope": "source.e2",
        "prefix": "rangerOffset",
        "description": "You input the range, a position vector, and a direction vector and it returns ranger data",
        "body": "rangerOffset(${1:number}, ${2:vector}, ${3:vector})"
    },
    "holoColor(nvn)": {
        "scope": "source.e2",
        "prefix": "holoColor",
        "description": "Sets the color and alpha of the hologram",
        "body": "holoColor(${1:number}, ${2:vector}, ${3:number})"
    },
    "printColor(r)": {
        "scope": "source.e2",
        "prefix": "printColor",
        "description": "Like printColor(...), except taking an array containing all the parameters",
        "body": "printColor(${1:array})"
    },
    "round(xv4n)": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds XYZW to argument 2's decimal precision",
        "body": "round(${1:vector4}, ${2:number})"
    },
    "writeString(snnnnn)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snnnn), with an extra argument for flashing text. 0 or 1 is recommended",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:number}, ${5:number}, ${6:number})"
    },
    "writeUnicodeString(snnvvn)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snnvv), with an extra argument for flashing text. 0 or 1 is recommended",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:vector}, ${5:vector}, ${6:number})"
    },
    "vec4(xv2nn)": {
        "scope": "source.e2",
        "prefix": "vec4",
        "description": "Converts a 2D vector into a 4D vector (the z and w components are set to the second and third arguments)",
        "body": "vec4(${1:vector2}, ${2:number}, ${3:number})"
    },
    "gShare": {
        "scope": "source.e2",
        "prefix": "gShare",
        "description": "Sets wether or not you want to share the variables. (1/0) Remember that there are two tables for each group: one which is shared and one which is not; values do not transition between the two",
        "body": "gShare(${1:number})"
    },
    "httpSuccess": {
        "scope": "source.e2",
        "prefix": "httpSuccess",
        "description": "Returns whether the previous request was successful",
        "body": "httpSuccess()"
    },
    "getAlpha": {
        "scope": "source.e2",
        "prefix": "getAlpha",
        "description": "e:getAlpha\nReturns the alpha of an entity",
        "body": "getAlpha()"
    },
    "holoModel": {
        "scope": "source.e2",
        "prefix": "holoModel",
        "description": "Sets the model.\nMust be from holoModelList unless wire_holograms_modelany is 1 (see holoModelAny())",
        "body": "holoModel(${1:number}, ${2:string})"
    },
    "setAlpha": {
        "scope": "source.e2",
        "prefix": "setAlpha",
        "description": "e:setAlpha\nSets the alpha of an entity",
        "body": "setAlpha(${1:number})"
    },
    "cot(c)": {
        "scope": "source.e2",
        "prefix": "cot",
        "description": "Calculates the cotangent of C",
        "body": "cot()"
    },
    "diagonal": {
        "scope": "source.e2",
        "prefix": "diagonal",
        "description": "Returns a 2D vector comprising the elements along the leading diagonal",
        "body": "diagonal(${3:vector2})"
    },
    "getSkin": {
        "scope": "source.e2",
        "prefix": "getSkin",
        "description": "e:getSkin\nGets Es current skin number",
        "body": "getSkin()"
    },
    "atan": {
        "scope": "source.e2",
        "prefix": "atan",
        "description": "Returns the inverse tangent of the argument, in degrees",
        "body": "atan(${1:number})"
    },
    "identity": {
        "scope": "source.e2",
        "prefix": "identity",
        "description": "Creates a 3x3 identity matrix",
        "body": "identity()"
    },
    "concmd": {
        "scope": "source.e2",
        "prefix": "concmd",
        "description": "Takes a string and executes it in console. Returns 1 if it succeeded and 0 if it failed.The client must enable this in the console with \"wire_expression2_concmd 1\". \"wire_expression2_concmd_whitelist\" allows you to choose which commands can be used.[http://www.wiremod.com/forum/151800-post12.html]",
        "body": "concmd(${1:string})"
    },
    "holoSkin": {
        "scope": "source.e2",
        "prefix": "holoSkin",
        "description": "Changes the skin of a hologram",
        "body": "holoSkin(${1:number}, ${2:number})"
    },
    "egpAlign": {
        "scope": "source.e2",
        "prefix": "egpAlign",
        "description": "xwl:egpAlign\nChanges the horizontal alignment. Works on: text and text layout. Number can be 0, 1 or 2",
        "body": "egpAlign(${1:number}, ${2:number})"
    },
    "findIncludeModel": {
        "scope": "source.e2",
        "prefix": "findIncludeModel",
        "description": "Include entities with this model (or partial model name) in future finds, and remove others not in the whitelist",
        "body": "findIncludeModel(${1:string})"
    },
    "comp(nn)": {
        "scope": "source.e2",
        "prefix": "comp",
        "description": "Returns a + b*i",
        "body": "comp(${1:number}, ${2:number})"
    },
    "dsClearGroups": {
        "scope": "source.e2",
        "prefix": "dsClearGroups",
        "description": "Leave all groups",
        "body": "dsClearGroups()"
    },
    "clamp(vvv)": {
        "scope": "source.e2",
        "prefix": "clamp",
        "description": "Clamps vector 1's XYZ between the XYZ of vector 2(min) and vector 3(max)",
        "body": "clamp(${1:vector}, ${2:vector}, ${3:vector})"
    },
    "setColumn(nnn)": {
        "scope": "source.e2",
        "prefix": "setColumn",
        "description": "xm2:setColumn\nSets the values of a column. The first argument given specifies the column(i), the following arguments are the values i1, i2",
        "body": "setColumn(${1:number}, ${2:number}, ${3:number})"
    },
    "deaths": {
        "scope": "source.e2",
        "prefix": "deaths",
        "description": "e:deaths\nReturns the number of times the player died",
        "body": "deaths()"
    },
    "element": {
        "scope": "source.e2",
        "prefix": "element",
        "description": "xm2:element\nReturns the element with indices (i,j)",
        "body": "element(${1:number}, ${2:number})"
    },
    "swapRows(nn)": {
        "scope": "source.e2",
        "prefix": "swapRows",
        "description": "xm4:swapRows\nSwaps the two rows specified",
        "body": "swapRows(${1:number}, ${2:number})"
    },
    "volume": {
        "scope": "source.e2",
        "prefix": "volume",
        "description": "e:volume\nGets the volume of the entity",
        "body": "volume()"
    },
    "setRow(nnn)": {
        "scope": "source.e2",
        "prefix": "setRow",
        "description": "xm2:setRow\nSets the values of a row. The first argument given specifies the row(j), the following arguments are the values 1j, 2j",
        "body": "setRow(${1:number}, ${2:number}, ${3:number})"
    },
    "httpCanRequest": {
        "scope": "source.e2",
        "prefix": "httpCanRequest",
        "description": "Returns whether you can make a new request (delay has been met or previous request timed out)",
        "body": "httpCanRequest()"
    },
    "convertUnit": {
        "scope": "source.e2",
        "prefix": "convertUnit",
        "description": "Converts between two units",
        "body": "convertUnit(${1:string}, ${2:string}, ${3:number})"
    },
    "dsGetScope": {
        "scope": "source.e2",
        "prefix": "dsGetScope",
        "description": "Returns the scope the E2 is currently in",
        "body": "dsGetScope()"
    },
    "writeUnicodeString(snnnn)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snnn), with an extra argument for background colour. 3-digit RGB again",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:number}, ${5:number})"
    },
    "isValidPhysics": {
        "scope": "source.e2",
        "prefix": "isValidPhysics",
        "description": "e:isValidPhysics\nReturns 1 if the entity has valid physics (players don't)",
        "body": "isValidPhysics()"
    },
    "randvec4": {
        "scope": "source.e2",
        "prefix": "randvec4",
        "description": "Returns a uniformly distributed, random, normalized direction vector",
        "body": "randvec4()"
    },
    "trace": {
        "scope": "source.e2",
        "prefix": "trace",
        "description": "Returns the trace of a matrix",
        "body": "trace(${3:vector2})"
    },
    "isOnGround": {
        "scope": "source.e2",
        "prefix": "isOnGround",
        "description": "e:isOnGround\nIs the player/NPC resting on something?",
        "body": "isOnGround()"
    },
    "date(n)": {
        "scope": "source.e2",
        "prefix": "date",
        "description": "Returns the specified unix time",
        "body": "date(${1:number})"
    },
    "hasOutput": {
        "scope": "source.e2",
        "prefix": "hasOutput",
        "description": "xwl:hasOutput\nReturns true if the linked component has an output of the specified name",
        "body": "hasOutput(${1:string})"
    },
    "keyLeftTurn": {
        "scope": "source.e2",
        "prefix": "keyLeftTurn",
        "description": "e:keyLeftTurn\nIs the player pressing their Look left key?",
        "body": "keyLeftTurn()"
    },
    "position": {
        "scope": "source.e2",
        "prefix": "position",
        "description": "xrd:position\nOutputs the position of the input ranger data trace IF it hit anything, else returns (0,0,0)",
        "body": "position()"
    },
    "min": {
        "scope": "source.e2",
        "prefix": "min",
        "description": "Returns the lowest value Argument",
        "body": "min(${1:number}, ${2:number})"
    },
    "identity4": {
        "scope": "source.e2",
        "prefix": "identity4",
        "description": "Creates a 4x4 identity matrix",
        "body": "identity4()"
    },
    "length()": {
        "scope": "source.e2",
        "prefix": "length",
        "description": "xv4:length\nGets the length of the vector",
        "body": "length()"
    },
    "boxSize": {
        "scope": "source.e2",
        "prefix": "boxSize",
        "description": "e:boxSize\nGets the dimensions of the entity's bounding box as a vector (length, width, height)",
        "body": "boxSize()"
    },
    "setRow(nnnn)": {
        "scope": "source.e2",
        "prefix": "setRow",
        "description": "m:setRow\nSets the values of a row. The first argument given specifies the row(j), the following arguments are the values 1j, 2j, 3j",
        "body": "setRow(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "acos": {
        "scope": "source.e2",
        "prefix": "acos",
        "description": "Returns the inverse cosine of the argument, in degrees",
        "body": "acos(${1:number})"
    },
    "max(nnnn)": {
        "scope": "source.e2",
        "prefix": "max",
        "description": "Returns the highest value Argument",
        "body": "max(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "setTrails(nnnsvnnn)": {
        "scope": "source.e2",
        "prefix": "setTrails",
        "description": "e:setTrails\nStartSize, EndSize, Length, Material, Color (RGB), Alpha, AttachmentID, Additive. Adds a trail to E with the specified attributes",
        "body": "setTrails(${1:number}, ${2:number}, ${3:number}, ${4:string}, ${5:vector}, ${6:number}, ${7:number}, ${8:number})"
    },
    "holoClipEnabled(nnn)": {
        "scope": "source.e2",
        "prefix": "holoClipEnabled",
        "description": "Enables / disables clipping for a hologram with specified index. Clip index is for use with multiple clipping planes",
        "body": "holoClipEnabled(${1:number}, ${2:number}, ${3:number})"
    },
    "gTable(s)": {
        "scope": "source.e2",
        "prefix": "gTable",
        "description": "Returns the gTable. The string determines group",
        "body": "gTable(${1:string})"
    },
    "holoScale": {
        "scope": "source.e2",
        "prefix": "holoScale",
        "description": "Returns the scale of the given hologram",
        "body": "holoScale(${1:number})"
    },
    "runOnSignal": {
        "scope": "source.e2",
        "prefix": "runOnSignal",
        "description": "If N2 == 0 the chip will no longer run on this signal, otherwise it makes this chip execute when signal S is sent by someone in scope N",
        "body": "runOnSignal(${1:string}, ${2:number}, ${3:number})"
    },
    "index": {
        "scope": "source.e2",
        "prefix": "index",
        "description": "s:index\nReturns Nth letter of the string, formatted as a string",
        "body": "index(${1:number})"
    },
    "randvec(vv)": {
        "scope": "source.e2",
        "prefix": "randvec",
        "description": "Returns a random vector between V1 and V2",
        "body": "randvec(${1:vector}, ${2:vector})"
    },
    "atan(nn)": {
        "scope": "source.e2",
        "prefix": "atan",
        "description": "Returns the inverse tangent of the arguments (arg1 / arg2), in degrees. This function accounts for positive/negative arguments, and arguments at or close to 0",
        "body": "atan(${1:number}, ${2:number})"
    },
    "soundPurge": {
        "scope": "source.e2",
        "prefix": "soundPurge",
        "description": "Clears the sound table and stops all sounds",
        "body": "soundPurge()"
    },
    "findExcludeClass": {
        "scope": "source.e2",
        "prefix": "findExcludeClass",
        "description": "Exclude entities with this class (or partial class name) from future finds",
        "body": "findExcludeClass(${1:string})"
    },
    "tanh(c)": {
        "scope": "source.e2",
        "prefix": "tanh",
        "description": "Calculates the hyperbolic tangent of C",
        "body": "tanh()"
    },
    "ranger": {
        "scope": "source.e2",
        "prefix": "ranger",
        "description": "You input max range, it returns ranger data",
        "body": "ranger(${1:number})"
    },
    "findAllowEntities": {
        "scope": "source.e2",
        "prefix": "findAllowEntities",
        "description": "Remove all entities in array from the blacklist",
        "body": "findAllowEntities(${1:array})"
    },
    "heading": {
        "scope": "source.e2",
        "prefix": "heading",
        "description": "Gets the elevation and bearing from the first position, at the specified angle, to the second position",
        "body": "heading(${1:vector}, ${2:angle}, ${3:vector})"
    },
    "bXor": {
        "scope": "source.e2",
        "prefix": "bXor",
        "description": "Performs bitwise XOR against the two numbers",
        "body": "bXor(${1:number}, ${2:number})"
    },
    "nobone": {
        "scope": "source.e2",
        "prefix": "nobone",
        "description": "Returns an invalid bone",
        "body": "nobone()"
    },
    "setDiagonal(nnnn)": {
        "scope": "source.e2",
        "prefix": "setDiagonal",
        "description": "xm4:setDiagonal\nSets the elements of the leading diagonal",
        "body": "setDiagonal(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "npcShoot": {
        "scope": "source.e2",
        "prefix": "npcShoot",
        "description": "e:npcShoot\nTells the NPC to shoot their gun",
        "body": "npcShoot()"
    },
    "owner()": {
        "scope": "source.e2",
        "prefix": "owner",
        "description": "e:owner\nGets the owner of an entity",
        "body": "owner()"
    },
    "npcGetTarget": {
        "scope": "source.e2",
        "prefix": "npcGetTarget",
        "description": "e:npcGetTarget\nReturns what the npc is currently targeting",
        "body": "npcGetTarget()"
    },
    "setMass(n)": {
        "scope": "source.e2",
        "prefix": "setMass",
        "description": "b:setMass\nSets the mass of the bone (between 0.001 and 50,000)",
        "body": "setMass(${1:number})"
    },
    "floor": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds the Argument down to the nearest Integer",
        "body": "floor(${1:number})"
    },
    "trimRight": {
        "scope": "source.e2",
        "prefix": "trimRight",
        "description": "s:trimRight\nTrims away spaces at the end of a string",
        "body": "trimRight()"
    },
    "ops": {
        "scope": "source.e2",
        "prefix": "ops",
        "description": "Returns how many ops are used every execution on average",
        "body": "ops()"
    },
    "distance2": {
        "scope": "source.e2",
        "prefix": "distance2",
        "description": "xv2:distance2\nGets the squared distance between 2D vectors",
        "body": "distance2(${1:vector2})"
    },
    "mod(xv2n)": {
        "scope": "source.e2",
        "prefix": "mod",
        "description": "Returns the remainder after XY have been divided by argument 2",
        "body": "mod(${1:vector2}, ${2:number})"
    },
    "entity()": {
        "scope": "source.e2",
        "prefix": "entity",
        "description": "xrd:entity\nReturns the entity of the input ranger data trace IF it hit an entity, else returns nil",
        "body": "entity()"
    },
    "holoCreate(nvvaxv4)": {
        "scope": "source.e2",
        "prefix": "holoCreate",
        "description": "Index, Position, Scale, Angle, Color (RGBA)\nCreates a new hologram entity",
        "body": "holoCreate(${1:number}, ${2:vector}, ${3:vector}, ${4:angle}, ${5:vector4})"
    },
    "holoModel(nsn)": {
        "scope": "source.e2",
        "prefix": "holoModel",
        "description": "Sets the model and skin.\nMust be from holoModelList unless wire_holograms_modelany is 1 (see holoModelAny())",
        "body": "holoModel(${1:number}, ${2:string}, ${3:number})"
    },
    "max(xv4xv4)": {
        "scope": "source.e2",
        "prefix": "max",
        "description": "Returns the vector with the greatest length",
        "body": "max(${1:vector4}, ${2:vector4})"
    },
    "roll": {
        "scope": "source.e2",
        "prefix": "roll",
        "description": "a:roll\nGets the roll of the angle",
        "body": "roll()"
    },
    "toRad": {
        "scope": "source.e2",
        "prefix": "toRad",
        "description": "Converts Degree angles to Radian angles",
        "body": "toRad(${1:number})"
    },
    "setW": {
        "scope": "source.e2",
        "prefix": "setW",
        "description": "xv4:setW\nReturns a copy of the 4D vector with W replaced (use as Vec4 = Vec4:setW(...))",
        "body": "setW(${1:number})"
    },
    "toWorld(v)": {
        "scope": "source.e2",
        "prefix": "toWorld",
        "description": "b:toWorld\nTransforms V from local coordinates (as seen from B) to world coordinates",
        "body": "toWorld(${1:vector})"
    },
    "egpUnParent": {
        "scope": "source.e2",
        "prefix": "egpUnParent",
        "description": "xwl:egpUnParent\nUn-parents the object",
        "body": "egpUnParent(${1:number})"
    },
    "vonEncode(t)": {
        "scope": "source.e2",
        "prefix": "vonEncode",
        "description": "Encodes a table into a string using vON",
        "body": "vonEncode(${1:table})"
    },
    "rowMatrix4": {
        "scope": "source.e2",
        "prefix": "rowMatrix4",
        "description": "Creates a 4x4 matrix with 4D vectors by rows",
        "body": "rowMatrix4(${1:vector4}, ${2:vector4}, ${3:vector4}, ${4:vector4})"
    },
    "egpQueueScreen": {
        "scope": "source.e2",
        "prefix": "egpQueueScreen",
        "description": "Returns the screen entity which the queue finished sending items for",
        "body": "egpQueueScreen()"
    },
    "maxPlayers": {
        "scope": "source.e2",
        "prefix": "maxPlayers",
        "description": "Returns the max number of players allowed in the server",
        "body": "maxPlayers()"
    },
    "time(t)": {
        "scope": "source.e2",
        "prefix": "time",
        "description": "Attempts to construct the time from the data in the given table (same as lua's os.time). The table structure must be the same as in the date() functions. If any values are missing or of the wrong type, that value is ignored (it will be nil)",
        "body": "time(${1:table})"
    },
    "lastSpoke": {
        "scope": "source.e2",
        "prefix": "lastSpoke",
        "description": "Returns the last player to speak",
        "body": "lastSpoke()"
    },
    "isWorld": {
        "scope": "source.e2",
        "prefix": "isWorld",
        "description": "e:isWorld\nIs the entity the world?",
        "body": "isWorld()"
    },
    "nearestPoint": {
        "scope": "source.e2",
        "prefix": "nearestPoint",
        "description": "e:nearestPoint\nReturns the closest point on the edge of the entity's bounding box to the given vector",
        "body": "nearestPoint(${1:vector})"
    },
    "randvec4(xv4xv4)": {
        "scope": "source.e2",
        "prefix": "randvec4",
        "description": "Returns a random vector between V1 and V2",
        "body": "randvec4(${1:vector4}, ${2:vector4})"
    },
    "randint": {
        "scope": "source.e2",
        "prefix": "randint",
        "description": "Returns a random integer from 1 to the specified value [1 <= x <= a ]",
        "body": "randint(${1:number})"
    },
    "egpScale": {
        "scope": "source.e2",
        "prefix": "egpScale",
        "description": "xwl:egpScale\nSets the scale of the screen's X axis to the first vector and Y axis to the second vector",
        "body": "egpScale(${1:vector2}, ${2:vector2})"
    },
    "dot(v)": {
        "scope": "source.e2",
        "prefix": "dot",
        "description": "v:dot\nGets the vector dot (scalar) product",
        "body": "dot(${1:vector})"
    },
    "isAlive": {
        "scope": "source.e2",
        "prefix": "isAlive",
        "description": "e:isAlive\nIs the player or NPC alive?",
        "body": "isAlive()"
    },
    "selfDestruct": {
        "scope": "source.e2",
        "prefix": "selfDestruct",
        "description": "Removes the expression",
        "body": "selfDestruct()"
    },
    "random(nn)": {
        "scope": "source.e2",
        "prefix": "random",
        "description": "Returns a random floating-point number between the specified interval [a <= x < b ]",
        "body": "random(${1:number}, ${2:number})"
    },
    "gRemoveAll": {
        "scope": "source.e2",
        "prefix": "gRemoveAll",
        "description": "Removes all non-shared variables and group tables you have created",
        "body": "gRemoveAll()"
    },
    "add(r)": {
        "scope": "source.e2",
        "prefix": "add",
        "description": "r:add\nAdds the contents of the second array to the end of the first array. Returns new array",
        "body": "add(${1:array})"
    },
    "sqrt(c)": {
        "scope": "source.e2",
        "prefix": "sqrt",
        "description": "Calculates the square root of C",
        "body": "sqrt()"
    },
    "quat(v)": {
        "scope": "source.e2",
        "prefix": "quat",
        "description": "Converts a vector to a quaternion (returns V.x*i + V.y*j + V.z*k)",
        "body": "quat(${1:vector})"
    },
    "aabbMin": {
        "scope": "source.e2",
        "prefix": "aabbMin",
        "description": "e:aabbMin\nReturns the entity's (min) axis-aligned bounding box",
        "body": "aabbMin()"
    },
    "findDisallowPlayerProps(e)": {
        "scope": "source.e2",
        "prefix": "findDisallowPlayerProps",
        "description": "Remove entities owned by specified player from the whitelist",
        "body": "findDisallowPlayerProps()"
    },
    "toString(nn)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Formats a number as a string, using argument 2 as the base. i.e. using 16 for base would convert the number to hex",
        "body": "toString(${1:number}, ${2:number})"
    },
    "isFrozen()": {
        "scope": "source.e2",
        "prefix": "isFrozen",
        "description": "b:isFrozen\nReturns 1 if B is frozen, 0 otherwise",
        "body": "isFrozen()"
    },
    "toRad(v)": {
        "scope": "source.e2",
        "prefix": "toRad",
        "description": "Converts the vector's magnitude from radians to radians",
        "body": "toRad(${1:vector})"
    },
    "abs(c)": {
        "scope": "source.e2",
        "prefix": "abs",
        "description": "Returns the absolute value of C",
        "body": "abs()"
    },
    "hint": {
        "scope": "source.e2",
        "prefix": "hint",
        "description": "Displays a hint popup with message S for N seconds (N being clamped between 0.7 and 7)",
        "body": "hint(${1:string}, ${2:number})"
    },
    "setColor(vn)": {
        "scope": "source.e2",
        "prefix": "setColor",
        "description": "e:setColor\nSets the color (as vector) and alpha (as number) of the entity",
        "body": "setColor(${1:vector}, ${2:number})"
    },
    "sinr": {
        "scope": "source.e2",
        "prefix": "sinr",
        "description": "Returns the sine of N radians",
        "body": "sinr(${1:number})"
    },
    "setZ(n)": {
        "scope": "source.e2",
        "prefix": "setZ",
        "description": "xv4:setZ\nReturns a copy of the 4D vector with Z replaced (use as Vec4 = Vec4:setZ(...))",
        "body": "setZ(${1:number})"
    },
    "setRadius": {
        "scope": "source.e2",
        "prefix": "setRadius",
        "description": "xef:setRadius\nSets the radius of the effect",
        "body": "setRadius(${1:number})"
    },
    "matrix(e)": {
        "scope": "source.e2",
        "prefix": "matrix",
        "description": "Creates a reference frame matrix from an entity's local direction vectors by columns in the order ( x, y, z )",
        "body": "matrix()"
    },
    "secondaryAmmoType": {
        "scope": "source.e2",
        "prefix": "secondaryAmmoType",
        "description": "e:secondaryAmmoType\nReturns the name of the secondary weapon's ammo",
        "body": "secondaryAmmoType()"
    },
    "egpFont(ns)": {
        "scope": "source.e2",
        "prefix": "egpFont",
        "description": "xwl:egpFont\nChanges the font of the text object",
        "body": "egpFont(${1:number}, ${2:string})"
    },
    "getConnectedEntities(r)": {
        "scope": "source.e2",
        "prefix": "getConnectedEntities",
        "description": "e:getConnectedEntities\nReturns an array with all entities directly or indirectly constrained or parented to E, including E itself.",
        "body": "getConnectedEntities(${1:array})"
    },
    "shiftR(xv4)": {
        "scope": "source.e2",
        "prefix": "shiftR",
        "description": "Shifts the vector's components right: shiftR( x,y,z,w ) = ( w,x,y,z )",
        "body": "shiftR(${1:vector4})"
    },
    "jsonEncode(t)": {
        "scope": "source.e2",
        "prefix": "jsonEncode",
        "description": "Encodes a table into a string using json",
        "body": "jsonEncode(${1:table})"
    },
    "holoBoneScale": {
        "scope": "source.e2",
        "prefix": "holoBoneScale",
        "description": "Returns the scale of the given hologram bone",
        "body": "holoBoneScale(${1:number}, ${2:number})"
    },
    "row": {
        "scope": "source.e2",
        "prefix": "row",
        "description": "xm:row\nReturns the row as a vector",
        "body": "row(${1:number})"
    },
    "setBodygroup": {
        "scope": "source.e2",
        "prefix": "setBodygroup",
        "description": "e:setBodygroup\nGroup ID, Group SubID\nSets the bodygroups of the given entity",
        "body": "setBodygroup(${1:number}, ${2:number})"
    },
    "angnorm": {
        "scope": "source.e2",
        "prefix": "angnorm",
        "description": "Gets the normalized angle of an angle",
        "body": "angnorm(${1:angle})"
    },
    "outerProduct(xv4)": {
        "scope": "source.e2",
        "prefix": "outerProduct",
        "description": "xv4:outerProduct\nGets the outer product (tensor product) and returns a matrix (tensor)",
        "body": "outerProduct(${1:vector4})"
    },
    "children": {
        "scope": "source.e2",
        "prefix": "children",
        "description": "e:children\nReturns an array containing all the children of the entity - that is, every entity whose parent is this entity",
        "body": "children()"
    },
    "clip1": {
        "scope": "source.e2",
        "prefix": "clip1",
        "description": "e:clip1\nReturns the amount of ammo in the primary clip of weapon E, -1 if there is no primary clip",
        "body": "clip1()"
    },
    "setStart": {
        "scope": "source.e2",
        "prefix": "setStart",
        "description": "xef:setStart\nSets the start of the effect",
        "body": "setStart(${1:vector})"
    },
    "holoClip(nvve)": {
        "scope": "source.e2",
        "prefix": "holoClip",
        "description": "Defines a plane used to clip a hologram specified by it's position, and direction local to the given entity",
        "body": "holoClip(${1:number}, ${2:vector}, ${3:vector})"
    },
    "rangerIgnoreWorld": {
        "scope": "source.e2",
        "prefix": "rangerIgnoreWorld",
        "description": "Default is 0, if any other value is given it will ignore world",
        "body": "rangerIgnoreWorld(${1:number})"
    },
    "yaw": {
        "scope": "source.e2",
        "prefix": "yaw",
        "description": "a:yaw\nGets the yaw of the angle",
        "body": "yaw()"
    },
    "round(a)": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds PYR to the nearest integer",
        "body": "round(${1:angle})"
    },
    "randvec": {
        "scope": "source.e2",
        "prefix": "randvec",
        "description": "Returns a uniformly distributed, random, normalized direction vector",
        "body": "randvec()"
    },
    "quat": {
        "scope": "source.e2",
        "prefix": "quat",
        "description": "Creates a zero quaternion",
        "body": "quat()"
    },
    "egpLine": {
        "scope": "source.e2",
        "prefix": "egpLine",
        "description": "xwl:egpLine\nCreates a line. First 2D vector is the start position, second is end position",
        "body": "egpLine(${1:number}, ${2:vector2}, ${3:vector2})"
    },
    "asin": {
        "scope": "source.e2",
        "prefix": "asin",
        "description": "Returns the inverse sine of the argument, in degrees",
        "body": "asin(${1:number})"
    },
    "mod(vn)": {
        "scope": "source.e2",
        "prefix": "mod",
        "description": "Returns the remainder after XYZ have been divided by argument 2",
        "body": "mod(${1:vector}, ${2:number})"
    },
    "health": {
        "scope": "source.e2",
        "prefix": "health",
        "description": "e:health\nGets the health of the entity",
        "body": "health()"
    },
    "egpAlpha": {
        "scope": "source.e2",
        "prefix": "egpAlpha",
        "description": "xwl:egpAlpha\nChanges the alpha (transparency) of an object",
        "body": "egpAlpha(${1:number}, ${2:number})"
    },
    "egpCanSendUmsg": {
        "scope": "source.e2",
        "prefix": "egpCanSendUmsg",
        "description": "Returns 1 if you can send an usermessage at the moment, 0 otherwise",
        "body": "egpCanSendUmsg()"
    },
    "ncount": {
        "scope": "source.e2",
        "prefix": "ncount",
        "description": "t:ncount\nReturns the number of sequential numerical indexes",
        "body": "ncount()"
    },
    "isCrouch": {
        "scope": "source.e2",
        "prefix": "isCrouch",
        "description": "e:isCrouch\nIs the player crouching?",
        "body": "isCrouch()"
    },
    "min(xv4xv4)": {
        "scope": "source.e2",
        "prefix": "min",
        "description": "Returns the vector with the smallest length",
        "body": "min(${1:vector4}, ${2:vector4})"
    },
    "toString(b)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Converts bone to string",
        "body": "toString(${1:bone})"
    },
    "npcRelationship(ssn)": {
        "scope": "source.e2",
        "prefix": "npcRelationship",
        "description": "e:npcRelationship\nSame as E:npcRelationship(entity,string,number), but sets relationship to an entire class specified by the first string. Example: \"npc_manhack\", \"prop_physics",
        "body": "npcRelationship(${1:string}, ${2:string}, ${3:number})"
    },
    "imag": {
        "scope": "source.e2",
        "prefix": "imag",
        "description": "Returns the imaginary part of C",
        "body": "imag()"
    },
    "findClosest": {
        "scope": "source.e2",
        "prefix": "findClosest",
        "description": "Returns the closest entity to the given point from the previous find event",
        "body": "findClosest(${1:vector})"
    },
    "cosr": {
        "scope": "source.e2",
        "prefix": "cosr",
        "description": "Returns the cosine of N radians",
        "body": "cosr(${1:number})"
    },
    "ceil(nn)": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds Argument 1 up to Argument 2's decimal precision",
        "body": "ceil(${1:number}, ${2:number})"
    },
    "boxCenterW": {
        "scope": "source.e2",
        "prefix": "boxCenterW",
        "description": "e:boxCenterW\nSame as using E:toWorld(E:boxCenter()), but since Lua is faster, this is more efficient (also shorter to write)",
        "body": "boxCenterW()"
    },
    "log(c)": {
        "scope": "source.e2",
        "prefix": "log",
        "description": "Calculates the natural logarithm of C",
        "body": "log()"
    },
    "setColor": {
        "scope": "source.e2",
        "prefix": "setColor",
        "description": "Sets the color of the E2 chip",
        "body": "setColor(${1:number}, ${2:number}, ${3:number})"
    },
    "matrix2(xm4)": {
        "scope": "source.e2",
        "prefix": "matrix2",
        "description": "Converts a 4x4 matrix into a 2x2 matrix - all (i,3), (i,4), (3,j) and (4,j) are omitted",
        "body": "matrix2(${3:vector4})"
    },
    "glonDecodeTable": {
        "scope": "source.e2",
        "prefix": "glonDecodeTable",
        "description": "Decodes a string into a table using GLON",
        "body": "glonDecodeTable(${1:string})"
    },
    "egpQueueClkPly": {
        "scope": "source.e2",
        "prefix": "egpQueueClkPly",
        "description": "Returns 1 if the current execution was caused by the EGP queue system, and the player E was the player who ordered the items to be sent",
        "body": "egpQueueClkPly()"
    },
    "setY": {
        "scope": "source.e2",
        "prefix": "setY",
        "description": "xv2:setY\nReturns a copy of the 2D vector with Y replaced (use as Vec2 = Vec2:setY(...))",
        "body": "setY(${1:number})"
    },
    "distance(v)": {
        "scope": "source.e2",
        "prefix": "distance",
        "description": "v:distance\nGets the distance between vectors",
        "body": "distance(${1:vector})"
    },
    "holoReset": {
        "scope": "source.e2",
        "prefix": "holoReset",
        "description": "Similar to holoCreate, but reusing the old entity",
        "body": "holoReset(${1:number}, ${2:string}, ${3:vector}, ${4:vector}, ${5:string})"
    },
    "findClearWhiteClassList": {
        "scope": "source.e2",
        "prefix": "findClearWhiteClassList",
        "description": "Clear all entries from the class whitelist",
        "body": "findClearWhiteClassList()"
    },
    "egpFidelity(nn)": {
        "scope": "source.e2",
        "prefix": "egpFidelity",
        "description": "xwl:egpFidelity\nChanges the fidelity of the object (the number of vertices the circle will use)",
        "body": "egpFidelity(${1:number}, ${2:number})"
    },
    "isVehicle": {
        "scope": "source.e2",
        "prefix": "isVehicle",
        "description": "e:isVehicle\nIs the entity a vehicle?",
        "body": "isVehicle()"
    },
    "setColumn(nxv4)": {
        "scope": "source.e2",
        "prefix": "setColumn",
        "description": "xm4:setColumn\nSets the values of a column. The first argument given specifies the column, the vector contains the values to set",
        "body": "setColumn(${1:number}, ${2:vector4})"
    },
    "egpResolution": {
        "scope": "source.e2",
        "prefix": "egpResolution",
        "description": "xwl:egpResolution\nSets the scale of the screen such that the top left corner is equal to the first vector and the bottom right corner is equal to the second vector",
        "body": "egpResolution(${1:vector2}, ${2:vector2})"
    },
    "sech(c)": {
        "scope": "source.e2",
        "prefix": "sech",
        "description": "Calculates the hyperbolic secant of C",
        "body": "sech()"
    },
    "rotate(nnn)": {
        "scope": "source.e2",
        "prefix": "rotate",
        "description": "v:rotate\nGets the rotated vector",
        "body": "rotate(${1:number}, ${2:number}, ${3:number})"
    },
    "mod(xv4xv4)": {
        "scope": "source.e2",
        "prefix": "mod",
        "description": "Returns the remainder after the components of vector 1 have been divided by the components of vector 2",
        "body": "mod(${1:vector4}, ${2:vector4})"
    },
    "fileRead": {
        "scope": "source.e2",
        "prefix": "fileRead",
        "description": "Returns the contents of the last uploaded file, or an empty string if there is no currently uploaded file",
        "body": "fileRead()"
    },
    "gmatch(sn)": {
        "scope": "source.e2",
        "prefix": "gmatch",
        "description": "s:gmatch\nruns string.gmatch(S, S2, N) and returns the captures in arrays in a table",
        "body": "gmatch(${1:string}, ${2:number})"
    },
    "mix(aan)": {
        "scope": "source.e2",
        "prefix": "mix",
        "description": "Combines angle 1's PYR with angle 2's PYR by a proportion given by argument 3 (between 0 and 1)",
        "body": "mix(${1:angle}, ${2:angle}, ${3:number})"
    },
    "angles()": {
        "scope": "source.e2",
        "prefix": "angles",
        "description": "b:angles\nReturns Bs pitch, yaw and roll angles",
        "body": "angles()"
    },
    "setMass": {
        "scope": "source.e2",
        "prefix": "setMass",
        "description": "Sets the mass of the E2 chip (between 0.001 and 50,000)",
        "body": "setMass(${1:number})"
    },
    "model": {
        "scope": "source.e2",
        "prefix": "model",
        "description": "e:model\nGets the model of an entity",
        "body": "model()"
    },
    "holoBoneScale(nsv)": {
        "scope": "source.e2",
        "prefix": "holoBoneScale",
        "description": "Sets the scale of the given hologram named bone, as a multiplier",
        "body": "holoBoneScale(${1:number}, ${2:string}, ${3:vector})"
    },
    "angVel": {
        "scope": "source.e2",
        "prefix": "angVel",
        "description": "e:angVel\nGets the angular velocity of the entity",
        "body": "angVel()"
    },
    "getMaterial": {
        "scope": "source.e2",
        "prefix": "getMaterial",
        "description": "e:getMaterial\nReturns the material of an entity",
        "body": "getMaterial()"
    },
    "boxMax": {
        "scope": "source.e2",
        "prefix": "boxMax",
        "description": "e:boxMax\nGets the maximum local XYZ of the entity's bounding box (the \"highest\" corner), as a local position vector",
        "body": "boxMax()"
    },
    "signalSend": {
        "scope": "source.e2",
        "prefix": "signalSend",
        "description": "Sends signal S to scope N. Additional calls to this function with the same signal will overwrite the old call until the signal is issued",
        "body": "signalSend(${1:string}, ${2:number})"
    },
    "signalGetGroup": {
        "scope": "source.e2",
        "prefix": "signalGetGroup",
        "description": "Gets the E-2's current signal group",
        "body": "signalGetGroup()"
    },
    "bezier": {
        "scope": "source.e2",
        "prefix": "bezier",
        "description": "Returns the 2D position on the bezier curve between the starting and ending 2D vector, given by the ratio (value between 0 and 1)",
        "body": "bezier(${1:vector2}, ${2:vector2}, ${3:vector2}, ${4:number})"
    },
    "inertia()": {
        "scope": "source.e2",
        "prefix": "inertia",
        "description": "b:inertia\nGets the principal components of Bs inertia tensor in the form vec(Ixx, Iyy, Izz)",
        "body": "inertia()"
    },
    "egpNumObjects": {
        "scope": "source.e2",
        "prefix": "egpNumObjects",
        "description": "xwl:egpNumObjects\nReturns the number of objects on the screen",
        "body": "egpNumObjects()"
    },
    "setName(s)": {
        "scope": "source.e2",
        "prefix": "setName",
        "description": "e:setName\nSet the name of another E2 or component name for other entities",
        "body": "setName(${1:string})"
    },
    "pi": {
        "scope": "source.e2",
        "prefix": "pi",
        "description": "Returns the constant PI",
        "body": "pi()"
    },
    "ceil(xv2n)": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds XY up to argument 2's decimal precision",
        "body": "ceil(${1:vector2}, ${2:number})"
    },
    "findRE": {
        "scope": "source.e2",
        "prefix": "findRE",
        "description": "s:findRE\nReturns the 1st occurrence of the string S using REGEX functions, returns 0 if not found",
        "body": "findRE(${1:string})"
    },
    "readString": {
        "scope": "source.e2",
        "prefix": "readString",
        "description": "xwl:readString\nReads a null-terminated string from the given address. Returns an empty string on failure",
        "body": "readString(${1:number})"
    },
    "velL": {
        "scope": "source.e2",
        "prefix": "velL",
        "description": "e:velL\nGets the local velocity of the entity",
        "body": "velL()"
    },
    "holoScale(nv)": {
        "scope": "source.e2",
        "prefix": "holoScale",
        "description": "Sets the scale of the given hologram, as a multiplier",
        "body": "holoScale(${1:number}, ${2:vector})"
    },
    "egpWedgeOutline": {
        "scope": "source.e2",
        "prefix": "egpWedgeOutline",
        "description": "xwl:egpWedgeOutline\nCreates a outline wedge object. Wedge objects are like circles, except they have a cake-piece-like mouth which you can change using egpSize",
        "body": "egpWedgeOutline(${1:number}, ${2:vector2}, ${3:vector2})"
    },
    "maxVec": {
        "scope": "source.e2",
        "prefix": "maxVec",
        "description": "Returns the vector combining the highest value components of V1 and V2",
        "body": "maxVec(${1:vector2}, ${2:vector2})"
    },
    "holoDelete": {
        "scope": "source.e2",
        "prefix": "holoDelete",
        "description": "Removes a hologram",
        "body": "holoDelete(${1:number})"
    },
    "matrix2(m)": {
        "scope": "source.e2",
        "prefix": "matrix2",
        "description": "Converts a 3x3 matrix into a 2x2 matrix - all (i,3) and (3,j) are omitted",
        "body": "matrix2()"
    },
    "findClearBlackEntityList": {
        "scope": "source.e2",
        "prefix": "findClearBlackEntityList",
        "description": "Clear all entries from the entity blacklist",
        "body": "findClearBlackEntityList()"
    },
    "isSuperAdmin": {
        "scope": "source.e2",
        "prefix": "isSuperAdmin",
        "description": "e:isSuperAdmin\nIs the player a super admin?",
        "body": "isSuperAdmin()"
    },
    "log(cc)": {
        "scope": "source.e2",
        "prefix": "log",
        "description": "Calculates the logarithm of C2 to a complex base C",
        "body": "log()"
    },
    "findClipToRegion": {
        "scope": "source.e2",
        "prefix": "findClipToRegion",
        "description": "Filters the list of entities by removing all entities NOT on the positive side of the defined plane. (Plane origin, vector perpendicular to the plane) You can define any convex hull using this",
        "body": "findClipToRegion(${1:vector}, ${2:vector})"
    },
    "gResetGroup": {
        "scope": "source.e2",
        "prefix": "gResetGroup",
        "description": "Resets the group back to \"default",
        "body": "gResetGroup()"
    },
    "matrix(xm2)": {
        "scope": "source.e2",
        "prefix": "matrix",
        "description": "Converts a 2x2 matrix into a 3x3 matrix - all (i,3) and (3,j) are filled with 0's",
        "body": "matrix(${3:vector2})"
    },
    "shift": {
        "scope": "source.e2",
        "prefix": "shift",
        "description": "Swaps the vector's x,y components",
        "body": "shift(${1:vector2})"
    },
    "gSetGroup": {
        "scope": "source.e2",
        "prefix": "gSetGroup",
        "description": "Sets the E2's current group. Does persist",
        "body": "gSetGroup(${1:string})"
    },
    "curtime": {
        "scope": "source.e2",
        "prefix": "curtime",
        "description": "Returns the current game time since server-start in seconds",
        "body": "curtime()"
    },
    "fileWrite": {
        "scope": "source.e2",
        "prefix": "fileWrite",
        "description": "Writes string data to the file overwriting it",
        "body": "fileWrite(${1:string}, ${2:string})"
    },
    "e": {
        "scope": "source.e2",
        "prefix": "e",
        "description": "Returns Euler's Constant",
        "body": "e()"
    },
    "setOrigin": {
        "scope": "source.e2",
        "prefix": "setOrigin",
        "description": "xef:setOrigin\nSets the origin of the effect",
        "body": "setOrigin(${1:vector})"
    },
    "timer": {
        "scope": "source.e2",
        "prefix": "timer",
        "description": "Sets a one-time timer with entered name and delay in milliseconds",
        "body": "timer(${1:string}, ${2:number})"
    },
    "clamp(xv4xv4xv4)": {
        "scope": "source.e2",
        "prefix": "clamp",
        "description": "Clamps vector 1's XYZW between the XYZW of vector 2(min) and vector 3(max)",
        "body": "clamp(${1:vector4}, ${2:vector4}, ${3:vector4})"
    },
    "invert(r)": {
        "scope": "source.e2",
        "prefix": "invert",
        "description": "Inverts the array, creating a lookup table",
        "body": "invert(${1:array})"
    },
    "id()": {
        "scope": "source.e2",
        "prefix": "id",
        "description": "r:id\nReturns the unique ID of the array",
        "body": "id()"
    },
    "findExcludeEntities": {
        "scope": "source.e2",
        "prefix": "findExcludeEntities",
        "description": "Exclude all entities in array from future finds",
        "body": "findExcludeEntities(${1:array})"
    },
    "egpGlobalPos": {
        "scope": "source.e2",
        "prefix": "egpGlobalPos",
        "description": "xwl:egpGlobalPos\nReturns the \"global\" (= it takes the parents' positions into consideration) position as a 3D vector. X and Y being the 2D X,Y coordinates, while Z is the angle",
        "body": "egpGlobalPos(${1:number})"
    },
    "setColor(n)": {
        "scope": "source.e2",
        "prefix": "setColor",
        "description": "xef:setColor\nSets the color of the effect. Color is represented by a byte",
        "body": "setColor(${1:number})"
    },
    "teamPlayers()": {
        "scope": "source.e2",
        "prefix": "teamPlayers",
        "description": "n:teamPlayers\nReturns the number of players of the team associated with the team number",
        "body": "teamPlayers()"
    },
    "holoRemainingSpawns": {
        "scope": "source.e2",
        "prefix": "holoRemainingSpawns",
        "description": "Returns how many holograms can be created this execution",
        "body": "holoRemainingSpawns()"
    },
    "distance": {
        "scope": "source.e2",
        "prefix": "distance",
        "description": "xv2:distance\nGets the distance between 2D vectors",
        "body": "distance(${1:vector2})"
    },
    "holoCreate(nvv)": {
        "scope": "source.e2",
        "prefix": "holoCreate",
        "description": "Index, Position, Scale\nCreates a new hologram entity",
        "body": "holoCreate(${1:number}, ${2:vector}, ${3:vector})"
    },
    "egpGlobalVertices": {
        "scope": "source.e2",
        "prefix": "egpGlobalVertices",
        "description": "xwl:egpGlobalVertices\nReturns an array of 2D vectors with the \"global\" positions of the vertices in the object",
        "body": "egpGlobalVertices(${1:number})"
    },
    "egpAngle(n)": {
        "scope": "source.e2",
        "prefix": "egpAngle",
        "description": "xwl:egpAngle\nReturns the angle of the object",
        "body": "egpAngle(${1:number})"
    },
    "setMaterial": {
        "scope": "source.e2",
        "prefix": "setMaterial",
        "description": "e:setMaterial\nSets the material of an entity",
        "body": "setMaterial(${1:string})"
    },
    "parentBone": {
        "scope": "source.e2",
        "prefix": "parentBone",
        "description": "e:parentBone\nReturns the bone E is parented to",
        "body": "parentBone()"
    },
    "reverse": {
        "scope": "source.e2",
        "prefix": "reverse",
        "description": "s:reverse\nReturns a reversed version of S",
        "body": "reverse()"
    },
    "holoPos": {
        "scope": "source.e2",
        "prefix": "holoPos",
        "description": "Sets the position of the hologram",
        "body": "holoPos(${1:number}, ${2:vector})"
    },
    "remove(s)": {
        "scope": "source.e2",
        "prefix": "remove",
        "description": "t:remove\nRemoves the specified entry from the table-part and returns 1 if removed",
        "body": "remove(${1:string})"
    },
    "findClearBlackModelList": {
        "scope": "source.e2",
        "prefix": "findClearBlackModelList",
        "description": "Clear all entries from the model blacklist",
        "body": "findClearBlackModelList()"
    },
    "atanr": {
        "scope": "source.e2",
        "prefix": "atanr",
        "description": "Returns the inverse tangent of the argument, in radians",
        "body": "atanr(${1:number})"
    },
    "max": {
        "scope": "source.e2",
        "prefix": "max",
        "description": "Returns the highest value Argument",
        "body": "max(${1:number}, ${2:number})"
    },
    "teamScore()": {
        "scope": "source.e2",
        "prefix": "teamScore",
        "description": "n:teamScore\nReturns the score of the team associated with the team number",
        "body": "teamScore()"
    },
    "play": {
        "scope": "source.e2",
        "prefix": "play",
        "description": "xef:play\nPlays the effect with given name (eg. watersplash)",
        "body": "play(${1:string})"
    },
    "fileCanList": {
        "scope": "source.e2",
        "prefix": "fileCanList",
        "description": "Returns 1 if the file list can be uploaded to the server",
        "body": "fileCanList()"
    },
    "random(n)": {
        "scope": "source.e2",
        "prefix": "random",
        "description": "Returns a random floating-point number between 0 and the specified value [0 <= x < a ]",
        "body": "random(${1:number})"
    },
    "mass": {
        "scope": "source.e2",
        "prefix": "mass",
        "description": "e:mass\nGets the mass of the entity",
        "body": "mass()"
    },
    "setColor(nnn)": {
        "scope": "source.e2",
        "prefix": "setColor",
        "description": "e:setColor\nSets the color of the entity",
        "body": "setColor(${1:number}, ${2:number}, ${3:number})"
    },
    "rgb2hsl(nnn)": {
        "scope": "source.e2",
        "prefix": "rgb2hsl",
        "description": "Converts N,N,N from RGB color space to the HSL color space",
        "body": "rgb2hsl(${1:number}, ${2:number}, ${3:number})"
    },
    "identity2": {
        "scope": "source.e2",
        "prefix": "identity2",
        "description": "Creates a 2x2 identity matrix",
        "body": "identity2()"
    },
    "isDedicated": {
        "scope": "source.e2",
        "prefix": "isDedicated",
        "description": "Returns 1 if server is dedicated, 0 if listen",
        "body": "isDedicated()"
    },
    "fileLoadingList": {
        "scope": "source.e2",
        "prefix": "fileLoadingList",
        "description": "Returns whether a list is currently uploading",
        "body": "fileLoadingList()"
    },
    "reset": {
        "scope": "source.e2",
        "prefix": "reset",
        "description": "Reset the expression itself as if it was just spawned, stops execution",
        "body": "reset()"
    },
    "egpCopy": {
        "scope": "source.e2",
        "prefix": "egpCopy",
        "description": "xwl:egpCopy\nCopies the settings of the second object into the first. If the first object does not exist, it's created",
        "body": "egpCopy(${1:number}, ${2:number})"
    },
    "vec(nnn)": {
        "scope": "source.e2",
        "prefix": "vec",
        "description": "Makes a 3D vector",
        "body": "vec(${1:number}, ${2:number}, ${3:number})"
    },
    "dsGetSender": {
        "scope": "source.e2",
        "prefix": "dsGetSender",
        "description": "Returns the entity of the E2 which sent the signal",
        "body": "dsGetSender()"
    },
    "rangerOffsetHull(vvvv)": {
        "scope": "source.e2",
        "prefix": "rangerOffsetHull",
        "description": "Inputs: StartPos, EndPos, Hull MinSize, Hull MaxSize",
        "body": "rangerOffsetHull(${1:vector}, ${2:vector}, ${3:vector}, ${4:vector})"
    },
    "stoptimer": {
        "scope": "source.e2",
        "prefix": "stoptimer",
        "description": "Stops a timer, can stop interval with stoptimer(\"interval\")",
        "body": "stoptimer(${1:string})"
    },
    "readCell": {
        "scope": "source.e2",
        "prefix": "readCell",
        "description": "xwl:readCell\nReturns contents of the specified memory cell. Deprecated, use XWL[N] instead",
        "body": "readCell(${1:number})"
    },
    "egpPos": {
        "scope": "source.e2",
        "prefix": "egpPos",
        "description": "xwl:egpPos\nReturns the position of the object",
        "body": "egpPos(${1:number})"
    },
    "sub": {
        "scope": "source.e2",
        "prefix": "sub",
        "description": "s:sub\nReturns a substring, starting at the number argument and ending at the end of the string",
        "body": "sub(${1:number})"
    },
    "boxCenter": {
        "scope": "source.e2",
        "prefix": "boxCenter",
        "description": "e:boxCenter\nGets the center of the entity's bounding box, as a local position vector",
        "body": "boxCenter()"
    },
    "toLocalAng": {
        "scope": "source.e2",
        "prefix": "toLocalAng",
        "description": "Converts a world position/angle to a local position/angle and returns the angle",
        "body": "toLocalAng(${1:vector}, ${2:angle}, ${3:vector}, ${4:angle})"
    },
    "glonEncode(t)": {
        "scope": "source.e2",
        "prefix": "glonEncode",
        "description": "Encodes a table into a string using GLON",
        "body": "glonEncode(${1:table})"
    },
    "lookupAttachment": {
        "scope": "source.e2",
        "prefix": "lookupAttachment",
        "description": "e:lookupAttachment\nReturns Es attachment ID associated with attachmentName",
        "body": "lookupAttachment(${1:string})"
    },
    "findDisallowPlayer(e)": {
        "scope": "source.e2",
        "prefix": "findDisallowPlayer",
        "description": "Remove specified player from the entity whitelist",
        "body": "findDisallowPlayer()"
    },
    "format": {
        "scope": "source.e2",
        "prefix": "format",
        "description": "Formats a values exactly like Lua's [http://www.lua.org/manual/5.1/manual.html#pdf-string.format string.format]. Any number and type of parameter can be passed through the \"...\". Prints errors to the chat area",
        "body": "format(${1:s...})"
    },
    "egpRoundedBoxOutline": {
        "scope": "source.e2",
        "prefix": "egpRoundedBoxOutline",
        "description": "xwl:egpRoundedBoxOutline\nCreates a rounded outline box. First 2D vector is the position, second is size",
        "body": "egpRoundedBoxOutline(${1:number}, ${2:vector2}, ${3:vector2})"
    },
    "toAngle(v)": {
        "scope": "source.e2",
        "prefix": "toAngle",
        "description": "v:toAngle\nConverts a direction vector into an angle with roll being determined by the up vector",
        "body": "toAngle(${1:vector})"
    },
    "min(xv2xv2)": {
        "scope": "source.e2",
        "prefix": "min",
        "description": "Returns the vector with the smallest length",
        "body": "min(${1:vector2}, ${2:vector2})"
    },
    "shootPos": {
        "scope": "source.e2",
        "prefix": "shootPos",
        "description": "e:shootPos\nReturns a players shoot position",
        "body": "shootPos()"
    },
    "attachmentPos(s)": {
        "scope": "source.e2",
        "prefix": "attachmentPos",
        "description": "e:attachmentPos\nSame as E:attachmentPos(E:lookupAttachment(attachmentName))",
        "body": "attachmentPos(${1:string})"
    },
    "lastSaidWhen": {
        "scope": "source.e2",
        "prefix": "lastSaidWhen",
        "description": "Returns the time the last message was sent",
        "body": "lastSaidWhen()"
    },
    "egpTrackerParent": {
        "scope": "source.e2",
        "prefix": "egpTrackerParent",
        "description": "xwl:egpTrackerParent\nReturns the parent entity of the 3D tracker object",
        "body": "egpTrackerParent(${1:number})"
    },
    "isSinglePlayer": {
        "scope": "source.e2",
        "prefix": "isSinglePlayer",
        "description": "Returns 1 if singleplayer, 0 if multiplayer",
        "body": "isSinglePlayer()"
    },
    "inertia": {
        "scope": "source.e2",
        "prefix": "inertia",
        "description": "e:inertia\nGets the principal components of the entity's inertia tensor in the form ( Ixx, Iyy, Izz )",
        "body": "inertia()"
    },
    "count": {
        "scope": "source.e2",
        "prefix": "count",
        "description": "xgt:count\nReturns the number of entries in the gTable. Does not add the entries in subtables",
        "body": "count()"
    },
    "dot(q)": {
        "scope": "source.e2",
        "prefix": "dot",
        "description": "q:dot\nReturns dot product of Q with Q2",
        "body": "dot()"
    },
    "setX": {
        "scope": "source.e2",
        "prefix": "setX",
        "description": "xv2:setX\nReturns a copy of the 2D vector with X replaced (use as Vec2 = Vec2:setX(...))",
        "body": "setX(${1:number})"
    },
    "merge": {
        "scope": "source.e2",
        "prefix": "merge",
        "description": "t:merge\nMerges T2 with T. Any variables with the same indexes are overwritten by T2's variables",
        "body": "merge(${1:table})"
    },
    "matrix4(e)": {
        "scope": "source.e2",
        "prefix": "matrix4",
        "description": "Creates a 4x4 reference frame matrix from an entity's local direction vectors by columns in the order (x, y, z, pos), with the bottom row (0,0,0,1)",
        "body": "matrix4()"
    },
    "mix": {
        "scope": "source.e2",
        "prefix": "mix",
        "description": "Combines vector 1's XY with vector 2's XY by a proportion given by argument 3 (between 0 and 1)",
        "body": "mix(${1:vector2}, ${2:vector2}, ${3:number})"
    },
    "matrix4(av)": {
        "scope": "source.e2",
        "prefix": "matrix4",
        "description": "Returns a 4x4 reference frame matrix as described by the angle A and the position V. Multiplying by this matrix will be the same as rotating by the given angle and offsetting by the given vector",
        "body": "matrix4(${1:angle}, ${2:vector})"
    },
    "teamDeaths()": {
        "scope": "source.e2",
        "prefix": "teamDeaths",
        "description": "n:teamDeaths\nReturns the number of deaths of the team associated with the team number",
        "body": "teamDeaths()"
    },
    "setColumn(nxv2)": {
        "scope": "source.e2",
        "prefix": "setColumn",
        "description": "xm2:setColumn\nSets the values of a column. The first argument given specifies the column, the vector contains the values to set",
        "body": "setColumn(${1:number}, ${2:vector2})"
    },
    "keyZoom": {
        "scope": "source.e2",
        "prefix": "keyZoom",
        "description": "e:keyZoom\nIs the player pressing their zoom key?",
        "body": "keyZoom()"
    },
    "massCenterL()": {
        "scope": "source.e2",
        "prefix": "massCenterL",
        "description": "b:massCenterL\nReturns Bs Center of Mass in local coordinates",
        "body": "massCenterL()"
    },
    "isPlayer": {
        "scope": "source.e2",
        "prefix": "isPlayer",
        "description": "e:isPlayer\nIs the entity a player?",
        "body": "isPlayer()"
    },
    "asin(c)": {
        "scope": "source.e2",
        "prefix": "asin",
        "description": "Calculates the inverse sine of C",
        "body": "asin()"
    },
    "randvec2(xv2xv2)": {
        "scope": "source.e2",
        "prefix": "randvec2",
        "description": "Returns a random vector between V1 and V2",
        "body": "randvec2(${1:vector2}, ${2:vector2})"
    },
    "tool": {
        "scope": "source.e2",
        "prefix": "tool",
        "description": "e:tool\nreturns the name of the tool the player E is currently holding",
        "body": "tool()"
    },
    "clipFromTypeid": {
        "scope": "source.e2",
        "prefix": "clipFromTypeid",
        "description": "t:clipFromTypeid\nRemoves all entries of the specified type",
        "body": "clipFromTypeid(${1:string})"
    },
    "rangerAngleHull(nnnvv)": {
        "scope": "source.e2",
        "prefix": "rangerAngleHull",
        "description": "Inputs: Distance, X Angle, Y Angle, Hull MinSize, Hull MaxSize",
        "body": "rangerAngleHull(${1:number}, ${2:number}, ${3:number}, ${4:vector}, ${5:vector})"
    },
    "egpToWorld": {
        "scope": "source.e2",
        "prefix": "egpToWorld",
        "description": "xwl:egpToWorld\nConverts a 2D vector on the screen or emitter into a 3D vector in the world",
        "body": "egpToWorld(${1:vector2})"
    },
    "findAllowPlayer(e)": {
        "scope": "source.e2",
        "prefix": "findAllowPlayer",
        "description": "Remove specified player from the entity blacklist",
        "body": "findAllowPlayer()"
    },
    "tan": {
        "scope": "source.e2",
        "prefix": "tan",
        "description": "Returns the tangent of N degrees",
        "body": "tan(${1:number})"
    },
    "signalClk(ssn)": {
        "scope": "source.e2",
        "prefix": "signalClk",
        "description": "Returns 1 if the chip was executed because the signal S2 was sent in the group S to the scope N. Returns 0 otherwise",
        "body": "signalClk(${1:string}, ${2:string}, ${3:number})"
    },
    "unset": {
        "scope": "source.e2",
        "prefix": "unset",
        "description": "t:unset\nForce removes the specified entry from the array-part, without moving subsequent entries down and returns 1 if removed",
        "body": "unset(${1:number})"
    },
    "teamFrags()": {
        "scope": "source.e2",
        "prefix": "teamFrags",
        "description": "n:teamFrags\nReturns the number of kills of the team associated with the team number",
        "body": "teamFrags()"
    },
    "getWeaponColor": {
        "scope": "source.e2",
        "prefix": "getWeaponColor",
        "description": "e:getWeaponColor\nReturns the player's weapon color as a vector (R,G,B)",
        "body": "getWeaponColor()"
    },
    "fileListTable": {
        "scope": "source.e2",
        "prefix": "fileListTable",
        "description": "Returns a table of file names that have been loaded. (Tbl[\"filename\"] = \"filename\")",
        "body": "fileListTable()"
    },
    "qMod": {
        "scope": "source.e2",
        "prefix": "qMod",
        "description": "Changes quaternion Q so that the represented rotation is by an angle between 0 and 180 degrees (by coder0xff)",
        "body": "qMod()"
    },
    "keyClk(e)": {
        "scope": "source.e2",
        "prefix": "keyClk",
        "description": "Returns 1 if the E2 was triggered by the player pressing a key or -1 when releasing a key",
        "body": "keyClk()"
    },
    "egpHudToggle": {
        "scope": "source.e2",
        "prefix": "egpHudToggle",
        "description": "xwl:egpHudToggle\nToggles the HUD on/off",
        "body": "egpHudToggle()"
    },
    "vec4(nnnn)": {
        "scope": "source.e2",
        "prefix": "vec4",
        "description": "Makes a 4D vector",
        "body": "vec4(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "matrix(vvv)": {
        "scope": "source.e2",
        "prefix": "matrix",
        "description": "Creates a matrix with vectors by columns",
        "body": "matrix(${1:vector}, ${2:vector}, ${3:vector})"
    },
    "isInWorld": {
        "scope": "source.e2",
        "prefix": "isInWorld",
        "description": "v:isInWorld\nReturns 1 if the position vector is within the world, 0 if not",
        "body": "isInWorld()"
    },
    "forward()": {
        "scope": "source.e2",
        "prefix": "forward",
        "description": "q:forward\nReturns vector pointing forward for Q",
        "body": "forward()"
    },
    "toString(a)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Gets the angle nicely formatted as a string \"[P,Y,R]",
        "body": "toString(${1:angle})"
    },
    "hasConstraints(s)": {
        "scope": "source.e2",
        "prefix": "hasConstraints",
        "description": "e:hasConstraints\nReturns the number of the constraints E has with the given constraint type",
        "body": "hasConstraints(${1:string})"
    },
    "keyUse": {
        "scope": "source.e2",
        "prefix": "keyUse",
        "description": "e:keyUse\nIs the player pressing their use key?",
        "body": "keyUse()"
    },
    "egpColor(nnnnn)": {
        "scope": "source.e2",
        "prefix": "egpColor",
        "description": "xwl:egpColor\nChanges the color and alpha of the object",
        "body": "egpColor(${1:number}, ${2:number}, ${3:number}, ${4:number}, ${5:number})"
    },
    "random": {
        "scope": "source.e2",
        "prefix": "random",
        "description": "Returns a random floating-point number between 0 and 1 [0 <= x < 1 ]",
        "body": "random()"
    },
    "lastSaid()": {
        "scope": "source.e2",
        "prefix": "lastSaid",
        "description": "e:lastSaid\nReturns what the player E last said",
        "body": "lastSaid()"
    },
    "rangerHull(nvv)": {
        "scope": "source.e2",
        "prefix": "rangerHull",
        "description": "Input: Distance, Hull MinSize, Hull MaxSize",
        "body": "rangerHull(${1:number}, ${2:vector}, ${3:vector})"
    },
    "row(n)": {
        "scope": "source.e2",
        "prefix": "row",
        "description": "xm4:row\nReturns the row as a 4D vector",
        "body": "row(${1:number})"
    },
    "positionLeftSolid": {
        "scope": "source.e2",
        "prefix": "positionLeftSolid",
        "description": "xrd:positionLeftSolid\nReturns the position at which the trace left the world, if it was started inside the world. Else return the trace's Start Position",
        "body": "positionLeftSolid()"
    },
    "setDamageType": {
        "scope": "source.e2",
        "prefix": "setDamageType",
        "description": "xef:setDamageType\nSets the damage type of the effect. See DMG_ Enums on GMod Wiki",
        "body": "setDamageType(${1:number})"
    },
    "soundPitch(snn)": {
        "scope": "source.e2",
        "prefix": "soundPitch",
        "description": "soundPitch(string Index, integer Pitch, integer Fadetime) Default Pitch is 100, max is 255. Pitch is scaled linearly (like frequency), rather than by octave",
        "body": "soundPitch(${1:string}, ${2:number}, ${3:number})"
    },
    "repeat": {
        "scope": "source.e2",
        "prefix": "repeat",
        "description": "s:repeat\nRepeats the input string N times",
        "body": "repeat(${1:number})"
    },
    "clamp": {
        "scope": "source.e2",
        "prefix": "clamp",
        "description": "If Arg1 = Arg3 (max) returns Arg3; otherwise returns Arg1",
        "body": "clamp(${1:number}, ${2:number}, ${3:number})"
    },
    "toString()": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "t:toString\nFormats the table as a human-readable string",
        "body": "toString()"
    },
    "mass()": {
        "scope": "source.e2",
        "prefix": "mass",
        "description": "b:mass\nReturns Bs mass",
        "body": "mass()"
    },
    "cschr": {
        "scope": "source.e2",
        "prefix": "cschr",
        "description": "Returns the hyperbolic cosecant of N radians",
        "body": "cschr(${1:number})"
    },
    "vec(xv2n)": {
        "scope": "source.e2",
        "prefix": "vec",
        "description": "Converts a 2D vector into a 3D vector (the z component is set to the second argument)",
        "body": "vec(${1:vector2}, ${2:number})"
    },
    "clkName": {
        "scope": "source.e2",
        "prefix": "clkName",
        "description": "Returns the name of the timer that caused current execution",
        "body": "clkName()"
    },
    "toLocal": {
        "scope": "source.e2",
        "prefix": "toLocal",
        "description": "e:toLocal\nTransforms from a world vector to a vector local to E",
        "body": "toLocal(${1:vector})"
    },
    "fileMaxSize": {
        "scope": "source.e2",
        "prefix": "fileMaxSize",
        "description": "Returns the maximum file size that can be uploaded or downloaded. Default is 300 KiB",
        "body": "fileMaxSize()"
    },
    "sub(nn)": {
        "scope": "source.e2",
        "prefix": "sub",
        "description": "s:sub\nReturns a substring, starting at the first number argument and ending at the second",
        "body": "sub(${1:number}, ${2:number})"
    },
    "timeQuota": {
        "scope": "source.e2",
        "prefix": "timeQuota",
        "description": "Returns the time quota in seconds",
        "body": "timeQuota()"
    },
    "root": {
        "scope": "source.e2",
        "prefix": "root",
        "description": "Returns the Nth Root of the first Argument",
        "body": "root(${1:number}, ${2:number})"
    },
    "hash": {
        "scope": "source.e2",
        "prefix": "hash",
        "description": "Returns a numerical hash using the code of the E2 itself (Including comments)",
        "body": "hash()"
    },
    "egpMaxObjects": {
        "scope": "source.e2",
        "prefix": "egpMaxObjects",
        "description": "Returns the maximum amount of objects you can have",
        "body": "egpMaxObjects()"
    },
    "rotationVector": {
        "scope": "source.e2",
        "prefix": "rotationVector",
        "description": "Returns the rotation vector - rotation axis where magnitude is the angle of rotation in degress (by coder0xff)",
        "body": "rotationVector()"
    },
    "x()": {
        "scope": "source.e2",
        "prefix": "x",
        "description": "xm4:x\nReturns the local x direction vector from a 4x4 coordinate reference frame matrix",
        "body": "x()"
    },
    "weapon()": {
        "scope": "source.e2",
        "prefix": "weapon",
        "description": "e:weapon\nReturns the weapon that player E is currently holding",
        "body": "weapon()"
    },
    "setRow(nnnnn)": {
        "scope": "source.e2",
        "prefix": "setRow",
        "description": "xm4:setRow\nSets the values of a row. The first argument given specifies the row(j), the following arguments are the values 1j, 2j, 3j, 4j",
        "body": "setRow(${1:number}, ${2:number}, ${3:number}, ${4:number}, ${5:number})"
    },
    "toLocal(a)": {
        "scope": "source.e2",
        "prefix": "toLocal",
        "description": "e:toLocal\nTransforms from a world angle to an angle local to E",
        "body": "toLocal(${1:angle})"
    },
    "gravity": {
        "scope": "source.e2",
        "prefix": "gravity",
        "description": "Returns gravity",
        "body": "gravity()"
    },
    "fileAppend": {
        "scope": "source.e2",
        "prefix": "fileAppend",
        "description": "Adds string data to the end of the file",
        "body": "fileAppend(${1:string}, ${2:string})"
    },
    "keyRightTurn": {
        "scope": "source.e2",
        "prefix": "keyRightTurn",
        "description": "e:keyRightTurn\nIs the player pressing their Look right key?",
        "body": "keyRightTurn()"
    },
    "writeString(snnn)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snn), with an extra argument for the text colour. This is in the form of a 3-digit RGB code. 0 is black, while 999 is white, 900 is pure red and so on",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:number})"
    },
    "writeUnicodeString(snnnv)": {
        "scope": "source.e2",
        "prefix": "writeUnicodeString",
        "description": "xwl:writeUnicodeString\nSame as XWL:writeUnicodeString(snnn), with an extra argument for background colour",
        "body": "writeUnicodeString(${1:string}, ${2:number}, ${3:number}, ${4:number}, ${5:vector})"
    },
    "aimBone": {
        "scope": "source.e2",
        "prefix": "aimBone",
        "description": "e:aimBone\nReturns the bone the player is currently aiming at",
        "body": "aimBone()"
    },
    "swapColumns": {
        "scope": "source.e2",
        "prefix": "swapColumns",
        "description": "xm2:swapColumns\nSwaps columns",
        "body": "swapColumns()"
    },
    "ceil(a)": {
        "scope": "source.e2",
        "prefix": "ceil",
        "description": "Rounds PYR up to the nearest integer",
        "body": "ceil(${1:angle})"
    },
    "getColor4": {
        "scope": "source.e2",
        "prefix": "getColor4",
        "description": "e:getColor4\nReturns the color of an entity as a 4D vector (R,G,B,A)",
        "body": "getColor4()"
    },
    "lockPod": {
        "scope": "source.e2",
        "prefix": "lockPod",
        "description": "e:lockPod\n1 locks and 0 unlocks the vehicle",
        "body": "lockPod(${1:number})"
    },
    "setPitch": {
        "scope": "source.e2",
        "prefix": "setPitch",
        "description": "a:setPitch\nReturns a copy of the angle with Pitch replaced (use as Ang = Ang:setPitch(...))",
        "body": "setPitch(${1:number})"
    },
    "egpColor(nxv4)": {
        "scope": "source.e2",
        "prefix": "egpColor",
        "description": "xwl:egpColor\nChanges the color and alpha of the object",
        "body": "egpColor(${1:number}, ${2:vector4})"
    },
    "clamp(xv2nn)": {
        "scope": "source.e2",
        "prefix": "clamp",
        "description": "Returns a vector in the same direction as vector 1, with length clamped between argument 2(min) and argument 3(max)",
        "body": "clamp(${1:vector2}, ${2:number}, ${3:number})"
    },
    "vec(xv2)": {
        "scope": "source.e2",
        "prefix": "vec",
        "description": "Converts a 2D vector into a 3D vector (the z component is set to 0)",
        "body": "vec(${1:vector2})"
    },
    "isSteamFriend": {
        "scope": "source.e2",
        "prefix": "isSteamFriend",
        "description": "e:isSteamFriend\nReturns if the given Entity is a steam friend of the first Entity",
        "body": "isSteamFriend()"
    },
    "mod(xv2xv2)": {
        "scope": "source.e2",
        "prefix": "mod",
        "description": "Returns the remainder after the components of vector 1 have been divided by the components of vector 2",
        "body": "mod(${1:vector2}, ${2:vector2})"
    },
    "clear": {
        "scope": "source.e2",
        "prefix": "clear",
        "description": "xgt:clear\nClears the gTable",
        "body": "clear()"
    },
    "rgb2digi": {
        "scope": "source.e2",
        "prefix": "rgb2digi",
        "description": "Converts the RGB vector V to a number in digital screen format. N Specifies a mode, either 0, 2 or 3, corresponding to Digital Screen color modes",
        "body": "rgb2digi(${1:vector}, ${2:number})"
    },
    "noranger": {
        "scope": "source.e2",
        "prefix": "noranger",
        "description": "Returns an invalid ranger",
        "body": "noranger()"
    },
    "match(sn)": {
        "scope": "source.e2",
        "prefix": "match",
        "description": "s:match\nruns string.match(S, S2, N) and returns the sub-captures as an array",
        "body": "match(${1:string}, ${2:number})"
    },
    "holoPlayerColor": {
        "scope": "source.e2",
        "prefix": "holoPlayerColor",
        "description": "Sets the sub-color of a hologram with player model such as clothes or physgun",
        "body": "holoPlayerColor(${1:number}, ${2:vector})"
    },
    "rangerDefaultZero": {
        "scope": "source.e2",
        "prefix": "rangerDefaultZero",
        "description": "If given any value other than 0 it will default the distance data to zero when nothing is hit",
        "body": "rangerDefaultZero(${1:number})"
    },
    "matrix2()": {
        "scope": "source.e2",
        "prefix": "matrix2",
        "description": "Creates a 2x2 zero matrix",
        "body": "matrix2()"
    },
    "unset(n)": {
        "scope": "source.e2",
        "prefix": "unset",
        "description": "r:unset\nForce removes the specified entry, without moving subsequent entries down and returns 1 if removed",
        "body": "unset(${1:number})"
    },
    "vec2()": {
        "scope": "source.e2",
        "prefix": "vec2",
        "description": "Same as vec2(0,0)",
        "body": "vec2()"
    },
    "matrix2(nnnn)": {
        "scope": "source.e2",
        "prefix": "matrix2",
        "description": "Creates a matrix with values in order (i.j) of: (1,1), (1,2), (2,1), (2,2)",
        "body": "matrix2(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "outerProduct(xv2)": {
        "scope": "source.e2",
        "prefix": "outerProduct",
        "description": "xv2:outerProduct\nGets the outer product (tensor product) and returns a matrix (tensor)",
        "body": "outerProduct(${1:vector2})"
    },
    "removeTrails": {
        "scope": "source.e2",
        "prefix": "removeTrails",
        "description": "e:removeTrails\nRemoves the trail from E",
        "body": "removeTrails()"
    },
    "aabbMax": {
        "scope": "source.e2",
        "prefix": "aabbMax",
        "description": "e:aabbMax\nReturns the entity's (max) axis-aligned bounding box",
        "body": "aabbMax()"
    },
    "ammoCount": {
        "scope": "source.e2",
        "prefix": "ammoCount",
        "description": "e:ammoCount\nReturns the amount of stored ammo of type S on player E, excluding current clip",
        "body": "ammoCount(${1:string})"
    },
    "maxHealth": {
        "scope": "source.e2",
        "prefix": "maxHealth",
        "description": "e:maxHealth\nGets the max health of the entity",
        "body": "maxHealth()"
    },
    "shiftL(xv4)": {
        "scope": "source.e2",
        "prefix": "shiftL",
        "description": "Shifts the vector's components left: shiftL( x,y,z,w ) = ( y,z,w,x )",
        "body": "shiftL(${1:vector4})"
    },
    "rotateAroundAxis": {
        "scope": "source.e2",
        "prefix": "rotateAroundAxis",
        "description": "a:rotateAroundAxis\nReturns the angle A rotated around vector V by N degrees",
        "body": "rotateAroundAxis(${1:vector}, ${2:number})"
    },
    "toString(n)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "n:toString\nFormats a number as a string, using argument 2 as the base. i.e. using 16 for base would convert the number to hex",
        "body": "toString(${1:number})"
    },
    "readArray": {
        "scope": "source.e2",
        "prefix": "readArray",
        "description": "xwl:readArray\nReads an array's elements from a piece of memory. Strings and sub-tables (angles, vectors, matrices) are written as pointers to the actual data. Strings are written null-terminated",
        "body": "readArray(${1:number}, ${2:number})"
    },
    "egpPoly(n...)": {
        "scope": "source.e2",
        "prefix": "egpPoly",
        "description": "xwl:egpPoly\nCreates a polygon with specified points as 2D/4D vectors (x,y)/(x,y,u,v)",
        "body": "egpPoly(${1:n...})"
    },
    "randvec2(nn)": {
        "scope": "source.e2",
        "prefix": "randvec2",
        "description": "Returns a random vector with its components between N1 and N2",
        "body": "randvec2(${1:number}, ${2:number})"
    },
    "quat(vv)": {
        "scope": "source.e2",
        "prefix": "quat",
        "description": "Creates a quaternion given forward (V) and up (V2) vectors",
        "body": "quat(${1:vector}, ${2:vector})"
    },
    "holoDisableShading": {
        "scope": "source.e2",
        "prefix": "holoDisableShading",
        "description": "If 1, supresses engine lighting when drawing this hologram",
        "body": "holoDisableShading(${1:number}, ${2:number})"
    },
    "flip": {
        "scope": "source.e2",
        "prefix": "flip",
        "description": "t:flip\nReturns a flipped copy of the table. Only affects string values in the array part and number values in the table part",
        "body": "flip()"
    },
    "egpCircle": {
        "scope": "source.e2",
        "prefix": "egpCircle",
        "description": "xwl:egpCircle\nCreates a circle. First 2D vector is the position, second is size",
        "body": "egpCircle(${1:number}, ${2:vector2}, ${3:vector2})"
    },
    "dot": {
        "scope": "source.e2",
        "prefix": "dot",
        "description": "xv2:dot\nGets the 2D vector dot (scalar) product",
        "body": "dot(${1:vector2})"
    },
    "isOnFire": {
        "scope": "source.e2",
        "prefix": "isOnFire",
        "description": "e:isOnFire\nIs the entity on fire?",
        "body": "isOnFire()"
    },
    "maxVec(vv)": {
        "scope": "source.e2",
        "prefix": "maxVec",
        "description": "Returns the vector combining the highest value components of V1 and V2",
        "body": "maxVec(${1:vector}, ${2:vector})"
    },
    "depth": {
        "scope": "source.e2",
        "prefix": "depth",
        "description": "t:depth\nReturns the depth at which the table is in, relative to its parents",
        "body": "depth()"
    },
    "gTableSafe": {
        "scope": "source.e2",
        "prefix": "gTableSafe",
        "description": "Returns a safe gTable which group is a numerical hash created from the code of the E2 itself",
        "body": "gTableSafe(${1:number})"
    },
    "bAnd": {
        "scope": "source.e2",
        "prefix": "bAnd",
        "description": "Performs bitwise AND against the two numbers",
        "body": "bAnd(${1:number}, ${2:number})"
    },
    "keyClkPressed": {
        "scope": "source.e2",
        "prefix": "keyClkPressed",
        "description": "Returns the name of the pressed/released key that triggered the E2",
        "body": "keyClkPressed()"
    },
    "z()": {
        "scope": "source.e2",
        "prefix": "z",
        "description": "xm4:z\nReturns the local z direction vector from a 4x4 coordinate reference frame matrix",
        "body": "z()"
    },
    "toDeg(a)": {
        "scope": "source.e2",
        "prefix": "toDeg",
        "description": "Converts the angle's magnitude from radians to degrees",
        "body": "toDeg(${1:angle})"
    },
    "rangerAngle": {
        "scope": "source.e2",
        "prefix": "rangerAngle",
        "description": "You input the distance, x-angle and y-angle (both in degrees) it returns ranger data",
        "body": "rangerAngle(${1:number}, ${2:number}, ${3:number})"
    },
    "min(nnn)": {
        "scope": "source.e2",
        "prefix": "min",
        "description": "Returns the lowest value Argument",
        "body": "min(${1:number}, ${2:number}, ${3:number})"
    },
    "sin": {
        "scope": "source.e2",
        "prefix": "sin",
        "description": "Returns the sine of N degrees",
        "body": "sin(${1:number})"
    },
    "perf": {
        "scope": "source.e2",
        "prefix": "perf",
        "description": "If used as a while loop condition, stabilizes the expression around hardquota used",
        "body": "perf()"
    },
    "floor(xv4)": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds XYZW down to the nearest integer",
        "body": "floor(${1:vector4})"
    },
    "findClipToName": {
        "scope": "source.e2",
        "prefix": "findClipToName",
        "description": "Filters the list of entities by removing all entities that do NOT have this name",
        "body": "findClipToName(${1:string})"
    },
    "writeTable": {
        "scope": "source.e2",
        "prefix": "writeTable",
        "description": "xwl:writeTable\nSame as writeArray, except it uses the numerically indexed variables of the table instead",
        "body": "writeTable(${1:number}, ${2:table})"
    },
    "findCount": {
        "scope": "source.e2",
        "prefix": "findCount",
        "description": "Returns the remaining available find calls",
        "body": "findCount()"
    },
    "hashNoComments": {
        "scope": "source.e2",
        "prefix": "hashNoComments",
        "description": "Returns a numerical hash using the code of the E2 itself (Excluding comments)",
        "body": "hashNoComments()"
    },
    "angSpeedLimit": {
        "scope": "source.e2",
        "prefix": "angSpeedLimit",
        "description": "Returns the angular speed limit",
        "body": "angSpeedLimit()"
    },
    "printColorC": {
        "scope": "source.e2",
        "prefix": "printColorC",
        "description": "Works like MsgC. Parameters can be any amount and combination of numbers, strings, player entities, color vectors (both 3D and 4D)",
        "body": "printColorC(${1:....})"
    },
    "ang(nnn)": {
        "scope": "source.e2",
        "prefix": "ang",
        "description": "Makes an angle",
        "body": "ang(${1:number}, ${2:number}, ${3:number})"
    },
    "toUnit": {
        "scope": "source.e2",
        "prefix": "toUnit",
        "description": "Converts default garrysmod units to specified units",
        "body": "toUnit(${1:string}, ${2:number})"
    },
    "setRow(nv)": {
        "scope": "source.e2",
        "prefix": "setRow",
        "description": "m:setRow\nSets the values of a row. The first argument given specifies the row, the vector contains the values to set",
        "body": "setRow(${1:number}, ${2:vector})"
    },
    "keyLeft": {
        "scope": "source.e2",
        "prefix": "keyLeft",
        "description": "e:keyLeft\nIs the player pressing their left key? (default A)",
        "body": "keyLeft()"
    },
    "duped": {
        "scope": "source.e2",
        "prefix": "duped",
        "description": "Returns 1 if the expression was duplicated",
        "body": "duped()"
    },
    "quat(e)": {
        "scope": "source.e2",
        "prefix": "quat",
        "description": "Converts angle of E to a quaternion",
        "body": "quat()"
    },
    "hit": {
        "scope": "source.e2",
        "prefix": "hit",
        "description": "xrd:hit\nReturns 1 if the input ranger data hit anything and 0 if it didn't",
        "body": "hit()"
    },
    "matrix4(a)": {
        "scope": "source.e2",
        "prefix": "matrix4",
        "description": "Returns a 4x4 reference frame matrix as described by the angle A. Multiplying by this matrix will be the same as rotating by the given angle",
        "body": "matrix4(${1:angle})"
    },
    "swapColumns()": {
        "scope": "source.e2",
        "prefix": "swapColumns",
        "description": "xm2:swapColumns\nSwaps columns",
        "body": "swapColumns()"
    },
    "signalSetGroup": {
        "scope": "source.e2",
        "prefix": "signalSetGroup",
        "description": "Sets the E-2's current signal group to S, this is applied during runOnSignal, signalSend, and signalSetOnRemove calls, so call it first",
        "body": "signalSetGroup(${1:string})"
    },
    "ranger(en)": {
        "scope": "source.e2",
        "prefix": "ranger",
        "description": "Same as ranger(distance): You input max range, it returns ranger data, only used on another entity",
        "body": "ranger(${2:number})"
    },
    "rgb2hsv(nnn)": {
        "scope": "source.e2",
        "prefix": "rgb2hsv",
        "description": "Converts N,N,N from the RGB to the HSV color space",
        "body": "rgb2hsv(${1:number}, ${2:number}, ${3:number})"
    },
    "eyeAngles": {
        "scope": "source.e2",
        "prefix": "eyeAngles",
        "description": "e:eyeAngles\nGets a players view direction",
        "body": "eyeAngles()"
    },
    "findIncludeEntities": {
        "scope": "source.e2",
        "prefix": "findIncludeEntities",
        "description": "Include all entities in array in future finds, and remove others not in the whitelist",
        "body": "findIncludeEntities(${1:array})"
    },
    "convar": {
        "scope": "source.e2",
        "prefix": "convar",
        "description": "Give a console command such as \"name\" and it returns the set value",
        "body": "convar(${1:string})"
    },
    "keySprint": {
        "scope": "source.e2",
        "prefix": "keySprint",
        "description": "e:keySprint\nIs the player pressing their sprint key?",
        "body": "keySprint()"
    },
    "vec4()": {
        "scope": "source.e2",
        "prefix": "vec4",
        "description": "Same as vec4(0,0,0,0)",
        "body": "vec4()"
    },
    "angVel()": {
        "scope": "source.e2",
        "prefix": "angVel",
        "description": "b:angVel\nReturns Bs angular velocity",
        "body": "angVel()"
    },
    "csc(c)": {
        "scope": "source.e2",
        "prefix": "csc",
        "description": "Calculates the cosecant of C",
        "body": "csc()"
    },
    "toLocal(v)": {
        "scope": "source.e2",
        "prefix": "toLocal",
        "description": "b:toLocal\nTransforms V from world coordinates to local coordinates (as seen from B)",
        "body": "toLocal(${1:vector})"
    },
    "isConstrainedTo(sn)": {
        "scope": "source.e2",
        "prefix": "isConstrainedTo",
        "description": "e:isConstrainedTo\nReturns the Nth entity E was constrained to with the given constraint type (see the types list below)",
        "body": "isConstrainedTo(${1:string}, ${2:number})"
    },
    "isinf": {
        "scope": "source.e2",
        "prefix": "isinf",
        "description": "Returns 1 if given value is a positive infinity or -1 if given value is a negative infinity; otherwise 0.",
        "body": "isinf(${1:number})"
    },
    "clamp(vnn)": {
        "scope": "source.e2",
        "prefix": "clamp",
        "description": "Returns a vector in the same direction as vector 1, with length clamped between argument 2(min) and argument 3(max)",
        "body": "clamp(${1:vector}, ${2:number}, ${3:number})"
    },
    "isTyping": {
        "scope": "source.e2",
        "prefix": "isTyping",
        "description": "e:isTyping\nIs the player typing a message in chat?",
        "body": "isTyping()"
    },
    "rangerFlags(s)": {
        "scope": "source.e2",
        "prefix": "rangerFlags",
        "description": "Sets the ranger flags. S can be any combination of I=ignore world, W=hit water, E=hit entities and Z=default to zero",
        "body": "rangerFlags(${1:string})"
    },
    "writeString(snnnvn)": {
        "scope": "source.e2",
        "prefix": "writeString",
        "description": "xwl:writeString\nSame as XWL:writeString(snnnv), with an extra argument for flashing text. 0 or 1 is recommended",
        "body": "writeString(${1:string}, ${2:number}, ${3:number}, ${4:number}, ${5:vector}, ${6:number})"
    },
    "clear()": {
        "scope": "source.e2",
        "prefix": "clear",
        "description": "r:clear\nClears the array",
        "body": "clear()"
    },
    "id": {
        "scope": "source.e2",
        "prefix": "id",
        "description": "e:id\nGets the numeric id of an entity",
        "body": "id()"
    },
    "toString(q)": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "Formats Q as a string",
        "body": "toString()"
    },
    "hitGroup": {
        "scope": "source.e2",
        "prefix": "hitGroup",
        "description": "xrd:hitGroup\nReturns the hit group (ie chest, face, left arm, right leg, etc)",
        "body": "hitGroup()"
    },
    "signalClearOnRemove": {
        "scope": "source.e2",
        "prefix": "signalClearOnRemove",
        "description": "Clears the signal that the chip sends when it is removed from the world",
        "body": "signalClearOnRemove()"
    },
    "elevation(v)": {
        "scope": "source.e2",
        "prefix": "elevation",
        "description": "b:elevation\nGets the elevation from the bone to the vector",
        "body": "elevation(${1:vector})"
    },
    "findClipToBox": {
        "scope": "source.e2",
        "prefix": "findClipToBox",
        "description": "Filters the list of entities by removing all entities NOT within the specified box",
        "body": "findClipToBox(${1:vector}, ${2:vector})"
    },
    "name": {
        "scope": "source.e2",
        "prefix": "name",
        "description": "e:name\nGets the name of a player",
        "body": "name()"
    },
    "bezier(vvvn)": {
        "scope": "source.e2",
        "prefix": "bezier",
        "description": "Returns the 3D vector position on the bezier curve between the starting and ending 3D vector, given by the ratio (value between 0 and 1)",
        "body": "bezier(${1:vector}, ${2:vector}, ${3:vector}, ${4:number})"
    },
    "bNot(nn)": {
        "scope": "source.e2",
        "prefix": "bNot",
        "description": "Performs a binary Not. The second argument is the length of the number you wish to perform Not on in bits",
        "body": "bNot(${1:number}, ${2:number})"
    },
    "findIncludePlayerProps": {
        "scope": "source.e2",
        "prefix": "findIncludePlayerProps",
        "description": "Include entities owned by player with specified name in future finds, and remove others not in the whitelist",
        "body": "findIncludePlayerProps(${1:string})"
    },
    "killPod": {
        "scope": "source.e2",
        "prefix": "killPod",
        "description": "e:killPod\nKills player in vehicle",
        "body": "killPod()"
    },
    "attachments": {
        "scope": "source.e2",
        "prefix": "attachments",
        "description": "e:attachments\nReturns array of attachment names of the entity",
        "body": "attachments()"
    },
    "shiftL": {
        "scope": "source.e2",
        "prefix": "shiftL",
        "description": "Shifts the vector's components left: shiftL( x,y,z ) = ( y,z,x )",
        "body": "shiftL(${1:vector})"
    },
    "rangerHitEntities": {
        "scope": "source.e2",
        "prefix": "rangerHitEntities",
        "description": "Default is 1, if value is given as 0 it will ignore entities",
        "body": "rangerHitEntities(${1:number})"
    },
    "concat()": {
        "scope": "source.e2",
        "prefix": "concat",
        "description": "r:concat\nConcatenates all values in the array",
        "body": "concat()"
    },
    "normalized": {
        "scope": "source.e2",
        "prefix": "normalized",
        "description": "xv2:normalized\nGets the normalized vector",
        "body": "normalized()"
    },
    "isUnderWater": {
        "scope": "source.e2",
        "prefix": "isUnderWater",
        "description": "e:isUnderWater\nIs the entity under water?",
        "body": "isUnderWater()"
    },
    "findDisallowClass": {
        "scope": "source.e2",
        "prefix": "findDisallowClass",
        "description": "Remove entities with this class (or partial class name) from the whitelist",
        "body": "findDisallowClass(${1:string})"
    },
    "playerConnectClk": {
        "scope": "source.e2",
        "prefix": "playerConnectClk",
        "description": "Returns 1 if the chip is being executed because of a player connect event. Returns 0 otherwise",
        "body": "playerConnectClk()"
    },
    "keyAttack1": {
        "scope": "source.e2",
        "prefix": "keyAttack1",
        "description": "e:keyAttack1\nIs the player pressing their primary fire key?",
        "body": "keyAttack1()"
    },
    "fraction": {
        "scope": "source.e2",
        "prefix": "fraction",
        "description": "xrd:fraction\nReturns a number between 0-1 which represents the percentage of the distance between the start & hit position of the trace. StartPos + (EndPos-StartPos):normalized() * RD:fraction() * (EndPos-StartPos):Length() is equal to RD:pos()",
        "body": "fraction()"
    },
    "cpuUsage()": {
        "scope": "source.e2",
        "prefix": "cpuUsage",
        "description": "e:cpuUsage\nReturns the average time per tick the server spends running the specified E2, in seconds (multiply it by 1000000 to get the same value as is displayed on the E2 overlay)",
        "body": "cpuUsage()"
    },
    "signalClk": {
        "scope": "source.e2",
        "prefix": "signalClk",
        "description": "Returns 1 if the chip was executed because of any signal, regardless of name, group or scope. Returns 0 otherwise",
        "body": "signalClk()"
    },
    "vonError": {
        "scope": "source.e2",
        "prefix": "vonError",
        "description": "Returns the last von error",
        "body": "vonError()"
    },
    "cos(c)": {
        "scope": "source.e2",
        "prefix": "cos",
        "description": "Calculates the cosine of C",
        "body": "cos()"
    },
    "keyBack": {
        "scope": "source.e2",
        "prefix": "keyBack",
        "description": "e:keyBack\nIs the player pressing their back key? (default S)",
        "body": "keyBack()"
    },
    "npcRelationshipByOwner": {
        "scope": "source.e2",
        "prefix": "npcRelationshipByOwner",
        "description": "e:npcRelationshipByOwner\nSets the NPC's relationship to all currently existing NPCs owned by player E. Returns number of entities added to relationships",
        "body": "npcRelationshipByOwner(${2:string}, ${3:number})"
    },
    "distance()": {
        "scope": "source.e2",
        "prefix": "distance",
        "description": "xrd:distance\nOutputs the distance from the rangerdata input, else depends on rangerDefault",
        "body": "distance()"
    },
    "rangerOffsetHull": {
        "scope": "source.e2",
        "prefix": "rangerOffsetHull",
        "description": "Inputs: StartPos, EndPos, Hull BoxSize",
        "body": "rangerOffsetHull(${1:vector}, ${2:vector}, ${3:vector})"
    },
    "getColor": {
        "scope": "source.e2",
        "prefix": "getColor",
        "description": "e:getColor\nReturns the color of an entity as a vector (R,G,B)",
        "body": "getColor()"
    },
    "angnorm(n)": {
        "scope": "source.e2",
        "prefix": "angnorm",
        "description": "Gets the normalized angle of a number",
        "body": "angnorm(${1:number})"
    },
    "egpSaveFrame(s)": {
        "scope": "source.e2",
        "prefix": "egpSaveFrame",
        "description": "xwl:egpSaveFrame\nSaves the frame under specified name",
        "body": "egpSaveFrame(${1:string})"
    },
    "adj": {
        "scope": "source.e2",
        "prefix": "adj",
        "description": "Returns the adjugate of a matrix (Does not work for 4x4 matrices)",
        "body": "adj()"
    },
    "log(q)": {
        "scope": "source.e2",
        "prefix": "log",
        "description": "Calculates natural logarithm of Q",
        "body": "log()"
    },
    "inputClk": {
        "scope": "source.e2",
        "prefix": "inputClk",
        "description": "Returns 1 if the expression was triggered by an input",
        "body": "inputClk()"
    },
    "getBodygroups": {
        "scope": "source.e2",
        "prefix": "getBodygroups",
        "description": "e:getBodygroups\nGroup ID\nReturns the number of bodygroups in the Group ID of the given entity",
        "body": "getBodygroups(${1:number})"
    },
    "massCenter": {
        "scope": "source.e2",
        "prefix": "massCenter",
        "description": "e:massCenter\nGets the Center of Mass of the entity",
        "body": "massCenter()"
    },
    "rotationAngle": {
        "scope": "source.e2",
        "prefix": "rotationAngle",
        "description": "Returns the angle of rotation in degrees (by coder0xff)",
        "body": "rotationAngle()"
    },
    "det": {
        "scope": "source.e2",
        "prefix": "det",
        "description": "Returns the determinant of a matrix (Does not work for 4x4 matrices)",
        "body": "det(${3:vector2})"
    },
    "egpHasObject": {
        "scope": "source.e2",
        "prefix": "egpHasObject",
        "description": "xwl:egpHasObject\nReturns 1 if the object with specified index exists on the screen, 0 if not",
        "body": "egpHasObject(${1:number})"
    },
    "toLocalPosAng": {
        "scope": "source.e2",
        "prefix": "toLocalPosAng",
        "description": "Converts a world position/angle to a local position/angle and returns both in an array",
        "body": "toLocalPosAng(${1:vector}, ${2:angle}, ${3:vector}, ${4:angle})"
    },
    "vec2(nn)": {
        "scope": "source.e2",
        "prefix": "vec2",
        "description": "Makes a 2D vector",
        "body": "vec2(${1:number}, ${2:number})"
    },
    "quat(c)": {
        "scope": "source.e2",
        "prefix": "quat",
        "description": "Creates a quaternion with real and \"i\" parts equal to C",
        "body": "quat()"
    },
    "angVelVector()": {
        "scope": "source.e2",
        "prefix": "angVelVector",
        "description": "b:angVelVector\nReturns rotation axis, velocity and direction given as the vector's direction, magnitude and sense",
        "body": "angVelVector()"
    },
    "csc": {
        "scope": "source.e2",
        "prefix": "csc",
        "description": "Returns the cosecant of N degrees",
        "body": "csc(${1:number})"
    },
    "qj(n)": {
        "scope": "source.e2",
        "prefix": "qj",
        "description": "Returns N*j",
        "body": "qj(${1:number})"
    },
    "toDeg(v)": {
        "scope": "source.e2",
        "prefix": "toDeg",
        "description": "Converts the vector's magnitude from radians to degrees",
        "body": "toDeg(${1:vector})"
    },
    "exit": {
        "scope": "source.e2",
        "prefix": "exit",
        "description": "Stops the execution of any code after it",
        "body": "exit()"
    },
    "gGetShare": {
        "scope": "source.e2",
        "prefix": "gGetShare",
        "description": "Returns 1/0",
        "body": "gGetShare()"
    },
    "npcDisp": {
        "scope": "source.e2",
        "prefix": "npcDisp",
        "description": "e:npcDisp\nReturns the NPC's relationship to entity E",
        "body": "npcDisp()"
    },
    "passenger": {
        "scope": "source.e2",
        "prefix": "passenger",
        "description": "e:passenger\nReturns the passenger of the vehicle if there is one, in single seat pods this will return the driver",
        "body": "passenger()"
    },
    "findSortByDistance": {
        "scope": "source.e2",
        "prefix": "findSortByDistance",
        "description": "Sorts the entities from the last find event, index 1 is the closest to point V, returns the number of entities in the list",
        "body": "findSortByDistance(${1:vector})"
    },
    "sec": {
        "scope": "source.e2",
        "prefix": "sec",
        "description": "Returns the secant of N degrees",
        "body": "sec(${1:number})"
    },
    "rangerOffsetHull(nvvv)": {
        "scope": "source.e2",
        "prefix": "rangerOffsetHull",
        "description": "Inputs: Distance, StartPos, Direction, Hull BoxSize",
        "body": "rangerOffsetHull(${1:number}, ${2:vector}, ${3:vector}, ${4:vector})"
    },
    "remove(n)": {
        "scope": "source.e2",
        "prefix": "remove",
        "description": "r:remove\nRemoves the specified entry, moving subsequent entries down to compensate and returns 1 if removed",
        "body": "remove(${1:number})"
    },
    "right()": {
        "scope": "source.e2",
        "prefix": "right",
        "description": "q:right\nReturns vector pointing right for Q",
        "body": "right()"
    },
    "players": {
        "scope": "source.e2",
        "prefix": "players",
        "description": "Returns an array containing all players on the server",
        "body": "players()"
    },
    "max(xv2xv2)": {
        "scope": "source.e2",
        "prefix": "max",
        "description": "Returns the vector with the greatest length",
        "body": "max(${1:vector2}, ${2:vector2})"
    },
    "toUnicodeChar(r)": {
        "scope": "source.e2",
        "prefix": "toUnicodeChar",
        "description": "Returns the UTF-8 string from the given Unicode code-points",
        "body": "toUnicodeChar(${1:array})"
    },
    "toString": {
        "scope": "source.e2",
        "prefix": "toString",
        "description": "n:toString\nFormats a number as a string. (Numbers may be concatenated into a string without using this function)",
        "body": "toString()"
    },
    "mod": {
        "scope": "source.e2",
        "prefix": "mod",
        "description": "Modulo, returns the Remainder after Argument 1 has been divided by Argument 2. Note \"mod(-1, 3) = -1",
        "body": "mod(${1:number}, ${2:number})"
    },
    "max(nnn)": {
        "scope": "source.e2",
        "prefix": "max",
        "description": "Returns the highest value Argument",
        "body": "max(${1:number}, ${2:number}, ${3:number})"
    },
    "aabbWorldMin": {
        "scope": "source.e2",
        "prefix": "aabbWorldMin",
        "description": "e:aabbWorldMin\nReturns the rotated entity's min world-axis-aligned bounding box corner",
        "body": "aabbWorldMin()"
    },
    "shiftL(a)": {
        "scope": "source.e2",
        "prefix": "shiftL",
        "description": "Shifts the angle's components left: shiftL( p,y,r ) = ( y,r,p )",
        "body": "shiftL(${1:angle})"
    },
    "k": {
        "scope": "source.e2",
        "prefix": "k",
        "description": "q:k\nReturns the k component of the quaternion",
        "body": "k()"
    },
    "hash(s)": {
        "scope": "source.e2",
        "prefix": "hash",
        "description": "Returns a numerical hash using the string specified",
        "body": "hash(${1:string})"
    },
    "lastDisconnectedPlayer": {
        "scope": "source.e2",
        "prefix": "lastDisconnectedPlayer",
        "description": "Returns the last player to disconnect. Must be done while in a disconnectClk() as anytime after the player object is gone.",
        "body": "lastDisconnectedPlayer()"
    },
    "ioInputEntity": {
        "scope": "source.e2",
        "prefix": "ioInputEntity",
        "description": "Returns the entity the input S is wired to",
        "body": "ioInputEntity(${1:string})"
    },
    "playerCanPrint": {
        "scope": "source.e2",
        "prefix": "playerCanPrint",
        "description": "Returns whether or not the next print-message will be printed or omitted by antispam",
        "body": "playerCanPrint()"
    },
    "find()": {
        "scope": "source.e2",
        "prefix": "find",
        "description": "Equivalent to findResult(1)",
        "body": "find()"
    },
    "mod(xv4n)": {
        "scope": "source.e2",
        "prefix": "mod",
        "description": "Returns the remainder after XYZW have been divided by argument 2",
        "body": "mod(${1:vector4}, ${2:number})"
    },
    "findAllowEntity": {
        "scope": "source.e2",
        "prefix": "findAllowEntity",
        "description": "Remove entity from the blacklist",
        "body": "findAllowEntity()"
    },
    "find(sn)": {
        "scope": "source.e2",
        "prefix": "find",
        "description": "s:find\nReturns the 1st occurrence of the string S starting at N and going to the end of the string, returns 0 if not found",
        "body": "find(${1:string}, ${2:number})"
    },
    "hitNormal": {
        "scope": "source.e2",
        "prefix": "hitNormal",
        "description": "xrd:hitNormal\nOutputs a normalized vector perpendicular to the surface the ranger is pointed at",
        "body": "hitNormal()"
    },
    "findClipFromBox": {
        "scope": "source.e2",
        "prefix": "findClipFromBox",
        "description": "Filters the list of entities by removing all entities within the specified box",
        "body": "findClipFromBox(${1:vector}, ${2:vector})"
    },
    "findClipFromSphere": {
        "scope": "source.e2",
        "prefix": "findClipFromSphere",
        "description": "Filters the list of entities by removing all entities within the specified sphere (center, radius)",
        "body": "findClipFromSphere(${1:vector}, ${2:number})"
    },
    "rangerOffset": {
        "scope": "source.e2",
        "prefix": "rangerOffset",
        "description": "You input two vector points, it returns ranger data",
        "body": "rangerOffset(${1:vector}, ${2:vector})"
    },
    "log2(c)": {
        "scope": "source.e2",
        "prefix": "log2",
        "description": "Calculates the logarithm of C to base 2",
        "body": "log2()"
    },
    "hardQuota": {
        "scope": "source.e2",
        "prefix": "hardQuota",
        "description": "Returns the size of the hard quota",
        "body": "hardQuota()"
    },
    "toNumber": {
        "scope": "source.e2",
        "prefix": "toNumber",
        "description": "s:toNumber\nParses a number from a string",
        "body": "toNumber()"
    },
    "sec(c)": {
        "scope": "source.e2",
        "prefix": "sec",
        "description": "Calculates the secant of C",
        "body": "sec()"
    },
    "maxVec(xv4xv4)": {
        "scope": "source.e2",
        "prefix": "maxVec",
        "description": "Returns the vector combining the highest value components of V1 and V2",
        "body": "maxVec(${1:vector4}, ${2:vector4})"
    },
    "egpColor4": {
        "scope": "source.e2",
        "prefix": "egpColor4",
        "description": "xwl:egpColor4\nReturns the color of the object as 4D vector (including alpha)",
        "body": "egpColor4(${1:number})"
    },
    "printTable": {
        "scope": "source.e2",
        "prefix": "printTable",
        "description": "Prints a table like the lua function PrintTable does, except to the chat area",
        "body": "printTable(${1:table})"
    },
    "ping": {
        "scope": "source.e2",
        "prefix": "ping",
        "description": "e:ping\nReturns the latency for player E",
        "body": "ping()"
    },
    "findClipFromModel": {
        "scope": "source.e2",
        "prefix": "findClipFromModel",
        "description": "Filters the list of entities by removing all entities that do have this model",
        "body": "findClipFromModel(${1:string})"
    },
    "toDeg(xv4)": {
        "scope": "source.e2",
        "prefix": "toDeg",
        "description": "Converts the vector's magnitude from radians to degrees",
        "body": "toDeg(${1:vector4})"
    },
    "frexp": {
        "scope": "source.e2",
        "prefix": "frexp",
        "description": "Returns the mantissa and exponent of the given floating-point number as a vector2 (X component holds a mantissa, and Y component holds an exponent)",
        "body": "frexp(${1:number})"
    },
    "concat(sn)": {
        "scope": "source.e2",
        "prefix": "concat",
        "description": "r:concat\nConcatenates all values in the array, starting at index N, with string S in between each",
        "body": "concat(${1:string}, ${2:number})"
    },
    "toTable()": {
        "scope": "source.e2",
        "prefix": "toTable",
        "description": "t:toTable\nConverts the table into a table",
        "body": "toTable()"
    },
    "findAllowModel": {
        "scope": "source.e2",
        "prefix": "findAllowModel",
        "description": "Remove entities with this model (or partial model name) from the blacklist",
        "body": "findAllowModel(${1:string})"
    },
    "matrix4(xv4xv4xv4xv4)": {
        "scope": "source.e2",
        "prefix": "matrix4",
        "description": "Creates a matrix with vectors by columns",
        "body": "matrix4(${1:vector4}, ${2:vector4}, ${3:vector4}, ${4:vector4})"
    },
    "holoColor": {
        "scope": "source.e2",
        "prefix": "holoColor",
        "description": "Sets the color and alpha of the hologram",
        "body": "holoColor(${1:number}, ${2:vector4})"
    },
    "pos()": {
        "scope": "source.e2",
        "prefix": "pos",
        "description": "xrd:pos\nReturns the hit position. The difference between this function and RD:position() is that if you start the trace inside the world, RD:position() will return the position at which the trace EXITS the world. RD:pos(), however, will continue on and return the hit position outside the wall you started the trace in",
        "body": "pos()"
    },
    "holoClipEnabled": {
        "scope": "source.e2",
        "prefix": "holoClipEnabled",
        "description": "Enables / disables clipping for a hologram with specified index",
        "body": "holoClipEnabled(${1:number}, ${2:number})"
    },
    "findDisallowEntities": {
        "scope": "source.e2",
        "prefix": "findDisallowEntities",
        "description": "Remove all entities in array from the whitelist",
        "body": "findDisallowEntities(${1:array})"
    },
    "applyTorque": {
        "scope": "source.e2",
        "prefix": "applyTorque",
        "description": "Applies torque to the E2 chip according to the given vector, representing the torque axis, magnitude and direction",
        "body": "applyTorque(${1:vector})"
    },
    "up()": {
        "scope": "source.e2",
        "prefix": "up",
        "description": "q:up\nReturns vector pointing up for Q",
        "body": "up()"
    },
    "findClearBlackClassList": {
        "scope": "source.e2",
        "prefix": "findClearBlackClassList",
        "description": "Clear all entries from the class blacklist",
        "body": "findClearBlackClassList()"
    },
    "quat(nnnn)": {
        "scope": "source.e2",
        "prefix": "quat",
        "description": "Returns N+N2i+N3j+N4k",
        "body": "quat(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "egpObjectContainsPoint": {
        "scope": "source.e2",
        "prefix": "egpObjectContainsPoint",
        "description": "xwl:egpObjectContainsPoint\nReturns 1 if the object with specified index contains the specified point",
        "body": "egpObjectContainsPoint(${1:number}, ${2:vector2})"
    },
    "bone": {
        "scope": "source.e2",
        "prefix": "bone",
        "description": "e:bone\nReturns Es Nth bone",
        "body": "bone(${1:number})"
    },
    "pointContents": {
        "scope": "source.e2",
        "prefix": "pointContents",
        "description": "Returns a string with all the \"content\" types in the vector point, seperated by commas",
        "body": "pointContents(${1:vector})"
    },
    "egpRunOnQueue": {
        "scope": "source.e2",
        "prefix": "egpRunOnQueue",
        "description": "xwl:egpRunOnQueue\nSet to 1 if you want your E2 to be triggered once the queue has finished sending all items in the queue for the screen",
        "body": "egpRunOnQueue(${1:number})"
    },
    "egpPolyOutline": {
        "scope": "source.e2",
        "prefix": "egpPolyOutline",
        "description": "xwl:egpPolyOutline\nCreates a outline polygon with specified points as array of 2D/4D vectors (x,y)/(x,y,u,v)",
        "body": "egpPolyOutline(${1:number}, ${2:array})"
    },
    "vec4(vn)": {
        "scope": "source.e2",
        "prefix": "vec4",
        "description": "Converts a 3D vector into a 4D vector (the w component is set to the second argument)",
        "body": "vec4(${1:vector}, ${2:number})"
    },
    "trace(xm4)": {
        "scope": "source.e2",
        "prefix": "trace",
        "description": "Returns the trace of a matrix",
        "body": "trace(${3:vector4})"
    },
    "tan(c)": {
        "scope": "source.e2",
        "prefix": "tan",
        "description": "Calculates the tangent of C",
        "body": "tan()"
    },
    "findPlayerBySteamID": {
        "scope": "source.e2",
        "prefix": "findPlayerBySteamID",
        "description": "Returns the player with the given SteamID32",
        "body": "findPlayerBySteamID(${1:string})"
    },
    "log10(c)": {
        "scope": "source.e2",
        "prefix": "log10",
        "description": "Calculates the logarithm of C to base 10",
        "body": "log10()"
    },
    "setMagnitude": {
        "scope": "source.e2",
        "prefix": "setMagnitude",
        "description": "xef:setMagnitude\nSets the magnitude of the effect",
        "body": "setMagnitude(${1:number})"
    },
    "findInSphere": {
        "scope": "source.e2",
        "prefix": "findInSphere",
        "description": "Finds entities in a sphere around V with a radius of N, returns the number found after filtering",
        "body": "findInSphere(${1:vector}, ${2:number})"
    },
    "outputType": {
        "scope": "source.e2",
        "prefix": "outputType",
        "description": "xwl:outputType\nReturns the type of output that S is in lowercase. ( \"NORMAL\" is changed to \"number\" )",
        "body": "outputType(${1:string})"
    },
    "noentity": {
        "scope": "source.e2",
        "prefix": "noentity",
        "description": "Returns an invalid entity",
        "body": "noentity()"
    },
    "egpLoadFrame(s)": {
        "scope": "source.e2",
        "prefix": "egpLoadFrame",
        "description": "xwl:egpLoadFrame\nLoads the frame with specified name",
        "body": "egpLoadFrame(${1:string})"
    },
    "y()": {
        "scope": "source.e2",
        "prefix": "y",
        "description": "xm4:y\nReturns the local y direction vector from a 4x4 coordinate reference frame matrix",
        "body": "y()"
    },
    "findToTable": {
        "scope": "source.e2",
        "prefix": "findToTable",
        "description": "Inserts the finds from an entity discovery event into an table's array-part and returns it. (Basically the same as findToArray())",
        "body": "findToTable()"
    },
    "holoScaleUnits": {
        "scope": "source.e2",
        "prefix": "holoScaleUnits",
        "description": "Returns the scale of the given hologram in source units",
        "body": "holoScaleUnits(${1:number})"
    },
    "adj(xm2)": {
        "scope": "source.e2",
        "prefix": "adj",
        "description": "Returns the adjugate of a matrix (Does not work for 4x4 matrices)",
        "body": "adj(${3:vector2})"
    },
    "floor(v)": {
        "scope": "source.e2",
        "prefix": "floor",
        "description": "Rounds XYZ down to the nearest integer",
        "body": "floor(${1:vector})"
    },
    "exp(q)": {
        "scope": "source.e2",
        "prefix": "exp",
        "description": "Raises Euler's constant e to the power Q",
        "body": "exp()"
    },
    "exp(c)": {
        "scope": "source.e2",
        "prefix": "exp",
        "description": "Raises Euler's constant e to the power of C",
        "body": "exp()"
    },
    "jsonDecode": {
        "scope": "source.e2",
        "prefix": "jsonDecode",
        "description": "Decodes a string into an array using json",
        "body": "jsonDecode(${1:string})"
    },
    "setElement(nnn)": {
        "scope": "source.e2",
        "prefix": "setElement",
        "description": "xm4:setElement\nSets an element's value. The first two arguments specify the indices (i,j), the third argument is the value to set it to",
        "body": "setElement(${1:number}, ${2:number}, ${3:number})"
    },
    "abs(q)": {
        "scope": "source.e2",
        "prefix": "abs",
        "description": "Returns absolute value of Q",
        "body": "abs()"
    },
    "soundPlay(sns)": {
        "scope": "source.e2",
        "prefix": "soundPlay",
        "description": "Plays sound from the E2 chip. soundPlay(string Index, int Duration, string Path to File)",
        "body": "soundPlay(${1:string}, ${2:number}, ${3:string})"
    },
    "holoCanCreate": {
        "scope": "source.e2",
        "prefix": "holoCanCreate",
        "description": "Returns 1 when holoCreate() will successfully create a new hologram until the Max limit is reached\nReplaces holoRemainingSpawns()",
        "body": "holoCanCreate()"
    },
    "rangerAngleHull": {
        "scope": "source.e2",
        "prefix": "rangerAngleHull",
        "description": "Inputs: Distance, X Angle, Y Angle, Hull BoxSize",
        "body": "rangerAngleHull(${1:number}, ${2:number}, ${3:number}, ${4:vector})"
    },
    "cot": {
        "scope": "source.e2",
        "prefix": "cot",
        "description": "Returns the cotangent of N degrees",
        "body": "cot(${1:number})"
    },
    "holoIndex": {
        "scope": "source.e2",
        "prefix": "holoIndex",
        "description": "Returns the index of the given hologram entity",
        "body": "holoIndex()"
    },
    "chatClk(e)": {
        "scope": "source.e2",
        "prefix": "chatClk",
        "description": "Returns 1 if the chip is being executed because of a chat event by player E. Returns 0 otherwise",
        "body": "chatClk()"
    },
    "ranger(nnn)": {
        "scope": "source.e2",
        "prefix": "ranger",
        "description": "Same as above with added inputs for X and Y skew",
        "body": "ranger(${1:number}, ${2:number}, ${3:number})"
    },
    "mod(vv)": {
        "scope": "source.e2",
        "prefix": "mod",
        "description": "Returns the remainder after the components of vector 1 have been divided by the components of vector 2",
        "body": "mod(${1:vector}, ${2:vector})"
    },
    "values": {
        "scope": "source.e2",
        "prefix": "values",
        "description": "t:values\nReturns an array with the values of the table (tables and arrays, which arrays do not support, are discarded)",
        "body": "values()"
    },
    "left": {
        "scope": "source.e2",
        "prefix": "left",
        "description": "s:left\nReturns N amount of characters starting from the leftmost character",
        "body": "left(${1:number})"
    },
    "cotr": {
        "scope": "source.e2",
        "prefix": "cotr",
        "description": "Returns the cotangent of N radians",
        "body": "cotr(${1:number})"
    },
    "setColumn": {
        "scope": "source.e2",
        "prefix": "setColumn",
        "description": "xm2:setColumn\nSets the values of a column. The first argument given specifies the column(i), the following arguments are the values i1, i2",
        "body": "setColumn(${1:number}, ${2:number}, ${3:number})"
    },
    "signalClk(s)": {
        "scope": "source.e2",
        "prefix": "signalClk",
        "description": "Returns 1 if the chip was executed because the signal S was sent, regardless of group or scope. Returns 0 otherwise",
        "body": "signalClk(${1:string})"
    },
    "error": {
        "scope": "source.e2",
        "prefix": "error",
        "description": "Shuts down the E2 with specified script error message",
        "body": "error(${1:string})"
    },
    "toWorldPosAng": {
        "scope": "source.e2",
        "prefix": "toWorldPosAng",
        "description": "Converts a local position/angle to a world position/angle and returns both in an array",
        "body": "toWorldPosAng(${1:vector}, ${2:angle}, ${3:vector}, ${4:angle})"
    },
    "stress": {
        "scope": "source.e2",
        "prefix": "stress",
        "description": "e:stress\nGets the stress of the entity",
        "body": "stress()"
    },
    "keyRight": {
        "scope": "source.e2",
        "prefix": "keyRight",
        "description": "e:keyRight\nIs the player pressing their right key? (default D)",
        "body": "keyRight()"
    },
    "explodeRE": {
        "scope": "source.e2",
        "prefix": "explodeRE",
        "description": "s:explodeRE\nSplits the string into an array, along the boundaries formed by the string pattern S. See also String.Explode",
        "body": "explodeRE(${1:string})"
    },
    "rotateAroundAxis(vn)": {
        "scope": "source.e2",
        "prefix": "rotateAroundAxis",
        "description": "v:rotateAroundAxis\nReturns the vector V1 rotated around vector V2 by N degrees",
        "body": "rotateAroundAxis(${1:vector}, ${2:number})"
    },
    "log(nc)": {
        "scope": "source.e2",
        "prefix": "log",
        "description": "Calculates the logarithm of C to a real base N",
        "body": "log(${1:number})"
    },
    "right": {
        "scope": "source.e2",
        "prefix": "right",
        "description": "s:right\nReturns N amount of characters starting from the rightmost character",
        "body": "right(${1:number})"
    },
    "mod(aa)": {
        "scope": "source.e2",
        "prefix": "mod",
        "description": "Returns the remainder after the components of angle 1 have been divided by the components of angle 2",
        "body": "mod(${1:angle}, ${2:angle})"
    },
    "rangerFilter": {
        "scope": "source.e2",
        "prefix": "rangerFilter",
        "description": "Feed entities you don't want the trace to hit",
        "body": "rangerFilter()"
    },
    "cosh": {
        "scope": "source.e2",
        "prefix": "cosh",
        "description": "Returns the hyperbolic cosine of N degrees",
        "body": "cosh(${1:number})"
    },
    "setSurfaceProp": {
        "scope": "source.e2",
        "prefix": "setSurfaceProp",
        "description": "xef:setSurfaceProp\nSets the surface property index of the effect",
        "body": "setSurfaceProp(${1:number})"
    },
    "array": {
        "scope": "source.e2",
        "prefix": "array",
        "description": "Creates an array",
        "body": "array(${1:....})"
    },
    "minIndex()": {
        "scope": "source.e2",
        "prefix": "minIndex",
        "description": "r:minIndex\nReturns the index of the smallest number in array",
        "body": "minIndex()"
    },
    "pop()": {
        "scope": "source.e2",
        "prefix": "pop",
        "description": "r:pop\nRemoves the last entry in the array and returns 1 if removed",
        "body": "pop()"
    },
    "toLocal(vava)": {
        "scope": "source.e2",
        "prefix": "toLocal",
        "description": "Converts a world position/angle to a local position/angle and returns the position",
        "body": "toLocal(${1:vector}, ${2:angle}, ${3:vector}, ${4:angle})"
    },
    "unicodeLength(nn)": {
        "scope": "source.e2",
        "prefix": "unicodeLength",
        "description": "s:unicodeLength\nReturns the length of the given UTF-8 string",
        "body": "unicodeLength(${1:number}, ${2:number})"
    },
    "mRotation": {
        "scope": "source.e2",
        "prefix": "mRotation",
        "description": "Creates a 3x3 rotation matrix, where the vector is the axis of rotation, and the number is the angle (anti-clockwise) in degrees. Example*: to rotate a vector (7,8,9) by 50 degrees about the axis (1,1,0), you would write V = mRotation(vec(1,1,0), 50) * vec(7,8,9)",
        "body": "mRotation(${1:vector}, ${2:number})"
    },
    "speedLimit": {
        "scope": "source.e2",
        "prefix": "speedLimit",
        "description": "Returns the speed limit",
        "body": "speedLimit()"
    },
    "findAllowClass": {
        "scope": "source.e2",
        "prefix": "findAllowClass",
        "description": "Remove entities with this class (or partial class name) from the blacklist",
        "body": "findAllowClass(${1:string})"
    },
    "teamDeaths": {
        "scope": "source.e2",
        "prefix": "teamDeaths",
        "description": "Returns the number of deaths of the team associated with the team number",
        "body": "teamDeaths(${1:number})"
    },
    "inrange": {
        "scope": "source.e2",
        "prefix": "inrange",
        "description": "Returns 1 if N is in the interval [N2; N3], 0 otherwise. This means it is equivalent to ((N2 <= N) & (N <= N3))",
        "body": "inrange(${1:number}, ${2:number}, ${3:number})"
    },
    "length2()": {
        "scope": "source.e2",
        "prefix": "length2",
        "description": "xv4:length2\nGets the squared length of the vector",
        "body": "length2()"
    },
    "shiftR": {
        "scope": "source.e2",
        "prefix": "shiftR",
        "description": "Shifts the vector's components right: shiftR( x,y,z ) = ( z,x,y )",
        "body": "shiftR(${1:vector})"
    },
    "keys": {
        "scope": "source.e2",
        "prefix": "keys",
        "description": "t:keys\nReturns an array with the keys of the table",
        "body": "keys()"
    },
    "holoCreate(nv)": {
        "scope": "source.e2",
        "prefix": "holoCreate",
        "description": "Index, Position\nCreates a new hologram entity",
        "body": "holoCreate(${1:number}, ${2:vector})"
    },
    "setColor(nnnn)": {
        "scope": "source.e2",
        "prefix": "setColor",
        "description": "e:setColor\nSets the color and alpha of the entity",
        "body": "setColor(${1:number}, ${2:number}, ${3:number}, ${4:number})"
    },
    "hitWorld": {
        "scope": "source.e2",
        "prefix": "hitWorld",
        "description": "xrd:hitWorld\nReturns 1 if the trace hit the world, 0 otherwise",
        "body": "hitWorld()"
    },
    "primaryAmmoType": {
        "scope": "source.e2",
        "prefix": "primaryAmmoType",
        "description": "e:primaryAmmoType\nReturns the name of the primary weapon's ammo",
        "body": "primaryAmmoType()"
    },
    "holoClip": {
        "scope": "source.e2",
        "prefix": "holoClip",
        "description": "Defines a plane used to clip a hologram specified by it's index, position, direction and number 1/0 whether the position should be global or local to the hologram",
        "body": "holoClip(${1:number}, ${2:number}, ${3:vector}, ${4:vector}, ${5:number})"
    },
    "sin(c)": {
        "scope": "source.e2",
        "prefix": "sin",
        "description": "Calculates the sine of C",
        "body": "sin()"
    },
    "boneCount": {
        "scope": "source.e2",
        "prefix": "boneCount",
        "description": "e:boneCount\nReturns Es number of bones",
        "body": "boneCount()"
    },
    "toRad(a)": {
        "scope": "source.e2",
        "prefix": "toRad",
        "description": "Converts the angle's magnitude from radians to radians",
        "body": "toRad(${1:angle})"
    },
    "findPlayerBySteamID64": {
        "scope": "source.e2",
        "prefix": "findPlayerBySteamID64",
        "description": "Returns the player with the given SteamID64",
        "body": "findPlayerBySteamID64(${1:string})"
    },
    "rangerHitWater": {
        "scope": "source.e2",
        "prefix": "rangerHitWater",
        "description": "Default is 0, if any other value is given it will hit water",
        "body": "rangerHitWater(${1:number})"
    },
    "round(vn)": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds XYZ to argument 2's decimal precision",
        "body": "round(${1:vector}, ${2:number})"
    },
    "maxFrictionMass": {
        "scope": "source.e2",
        "prefix": "maxFrictionMass",
        "description": "Returns how much friction influences props throughout the server",
        "body": "maxFrictionMass()"
    },
    "inrange(xv2xv2xv2)": {
        "scope": "source.e2",
        "prefix": "inrange",
        "description": "Returns 1 if each component of V is between (or is equal to) the components of Vmin and Vmax",
        "body": "inrange(${1:vector2}, ${2:vector2}, ${3:vector2})"
    },
    "findInCone": {
        "scope": "source.e2",
        "prefix": "findInCone",
        "description": "Like findInSphere but with a http://mathworld.wolfram.com/SphericalCone.html Spherical cone, arguments are for position, direction, length, and degrees (works now)",
        "body": "findInCone(${1:vector}, ${2:vector}, ${3:number}, ${4:number})"
    },
    "cross": {
        "scope": "source.e2",
        "prefix": "cross",
        "description": "xv2:cross\nGets the 2D vector cross product/wedge product",
        "body": "cross(${1:vector2})"
    },
    "positive(xv4)": {
        "scope": "source.e2",
        "prefix": "positive",
        "description": "Returns a vector containing the positive value of each vector component, equivalent to abs(N)",
        "body": "positive(${1:vector4})"
    },
    "playerDisconnectClk": {
        "scope": "source.e2",
        "prefix": "playerDisconnectClk",
        "description": "Returns 1 if the chip is being executed because of a player disconnect event. Returns 0 otherwise",
        "body": "playerDisconnectClk()"
    },
    "dateUTC(n)": {
        "scope": "source.e2",
        "prefix": "dateUTC",
        "description": "Returns the specified unix time in UTC",
        "body": "dateUTC(${1:number})"
    },
    "time": {
        "scope": "source.e2",
        "prefix": "time",
        "description": "Returns the time in seconds",
        "body": "time()"
    },
    "timeConnected": {
        "scope": "source.e2",
        "prefix": "timeConnected",
        "description": "e:timeConnected\nReturns a players time connected to a server",
        "body": "timeConnected()"
    },
    "egpRemove": {
        "scope": "source.e2",
        "prefix": "egpRemove",
        "description": "xwl:egpRemove\nRemoves the object from the screen",
        "body": "egpRemove(${1:number})"
    },
    "atan2": {
        "scope": "source.e2",
        "prefix": "atan2",
        "description": "Calculates the principle value of C",
        "body": "atan2()"
    },
    "setYaw": {
        "scope": "source.e2",
        "prefix": "setYaw",
        "description": "a:setYaw\nReturns a copy of the angle with Yaw replaced (use as Ang = Ang:setYaw(...))",
        "body": "setYaw(${1:number})"
    },
    "round(nn)": {
        "scope": "source.e2",
        "prefix": "round",
        "description": "Rounds Argument 1 to Argument 2's decimal precision",
        "body": "round(${1:number}, ${2:number})"
    },
    "egpSize(nxv2)": {
        "scope": "source.e2",
        "prefix": "egpSize",
        "description": "xwl:egpSize\nChanges the size of the object",
        "body": "egpSize(${1:number}, ${2:vector2})"
    },
    "matrix": {
        "scope": "source.e2",
        "prefix": "matrix",
        "description": "Creates a 3x3 zero matrix",
        "body": "matrix()"
    },
    "setRow(nxv2)": {
        "scope": "source.e2",
        "prefix": "setRow",
        "description": "xm2:setRow\nSets the values of a row. The first argument given specifies the row, the vector contains the values to set",
        "body": "setRow(${1:number}, ${2:vector2})"
    },
    "qRotation(v)": {
        "scope": "source.e2",
        "prefix": "qRotation",
        "description": "Construct a quaternion from the rotation vector V. Vector direction is axis of rotation, magnitude is angle in degress (by coder0xff)",
        "body": "qRotation(${1:vector})"
    },
    "dsJoinGroup": {
        "scope": "source.e2",
        "prefix": "dsJoinGroup",
        "description": "Join the group to receive signals from it",
        "body": "dsJoinGroup(${1:string})"
    },
    "heading(v)": {
        "scope": "source.e2",
        "prefix": "heading",
        "description": "b:heading\nGets the elevation and bearing from the bone to the vector",
        "body": "heading(${1:vector})"
    },
    "findResult": {
        "scope": "source.e2",
        "prefix": "findResult",
        "description": "Returns the indexed entity from the previous find event (valid parameters are 1 to the number of entities found)",
        "body": "findResult(${1:number})"
    },
    "log": {
        "scope": "source.e2",
        "prefix": "log",
        "description": "Returns the logarithm to base Argument 2 of Argument 1",
        "body": "log(${1:number}, ${2:number})"
    },
    "egpParent(ne)": {
        "scope": "source.e2",
        "prefix": "egpParent",
        "description": "xwl:egpParent\nParents the 3D tracker object to an entity",
        "body": "egpParent(${1:number})"
    },
    "cos": {
        "scope": "source.e2",
        "prefix": "cos",
        "description": "Returns the cosine of N degrees",
        "body": "cos(${1:number})"
    },
    "findByModel": {
        "scope": "source.e2",
        "prefix": "findByModel",
        "description": "Find all entities with the given model",
        "body": "findByModel(${1:string})"
    },
    "matType": {
        "scope": "source.e2",
        "prefix": "matType",
        "description": "xrd:matType\nReturns the material type (ie wood, metal, dirt, flesh, etc)",
        "body": "matType()"
    },
    "npcGiveWeapon(s)": {
        "scope": "source.e2",
        "prefix": "npcGiveWeapon",
        "description": "e:npcGiveWeapon\nGives the NPC a weapon. Example: E:npcGiveWeapon(\"pistol\"). Other arguments include \"ar2\", \"crowbar\", \"357\", \"shotgun\", \"crossbow\", \"rpg\", \"frag\", etc. Other such as the bugbait or slam may be buggy",
        "body": "npcGiveWeapon(${1:string})"
    },
    "holoScaleUnits(nv)": {
        "scope": "source.e2",
        "prefix": "holoScaleUnits",
        "description": "Sets the scale of the given hologram, in source units",
        "body": "holoScaleUnits(${1:number}, ${2:vector})"
    },
    "sum": {
        "scope": "source.e2",
        "prefix": "sum",
        "description": "r:sum\nAdds all numbers in the array together and returns result",
        "body": "sum()"
    },
    "fileLoadedList": {
        "scope": "source.e2",
        "prefix": "fileLoadedList",
        "description": "If the list has been loaded and it is called, it will return 1. Any time after that until a new list is loaded it will return 0",
        "body": "fileLoadedList()"
    },
    "egpFiltering": {
        "scope": "source.e2",
        "prefix": "egpFiltering",
        "description": "xwl:egpFiltering\nChanges the texture filter used to draw the object. Works on objects that draw a material. See _TEXFILTER constants (POINT=sharp, ANISOTROPIC=blurry/default)",
        "body": "egpFiltering(${1:number}, ${2:number})"
    },
    "conj(q)": {
        "scope": "source.e2",
        "prefix": "conj",
        "description": "Returns the conjugate of Q",
        "body": "conj()"
    },
    "systime": {
        "scope": "source.e2",
        "prefix": "systime",
        "description": "Returns a highly accurate time (also in seconds) since the server was started. Ideal for benchmarking",
        "body": "systime()"
    },
    "frags": {
        "scope": "source.e2",
        "prefix": "frags",
        "description": "e:frags\nReturns the number of kills the player has made",
        "body": "frags()"
    },
    "distance(xv4)": {
        "scope": "source.e2",
        "prefix": "distance",
        "description": "xv4:distance\nGets the distance between 4D vectors",
        "body": "distance(${1:vector4})"
    },
    "egpObjectTypes": {
        "scope": "source.e2",
        "prefix": "egpObjectTypes",
        "description": "xwl:egpObjectTypes\nReturns an array whose keys are bound to object index, and value being the type of particular object",
        "body": "egpObjectTypes()"
    },
    "func": {
        "scope": "source.e2",
        "prefix": "func",
        "description": "Creates E2 function",
        "body": "function ${1:type} ${2:name}(${3:params..}) {\n\n}"
    }
}
